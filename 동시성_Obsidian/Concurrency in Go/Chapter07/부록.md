

동시 코드를 작성하는 여정을 떠나면서, 프로그램 작성 및 정확성 분석을 위한 도구와, 프로그램 내에서 일어나는 일을 이해하는 데 도움이 되는 몇 가지 유용한 지침이 필요할 것이다. 다행스럽게도 Go 생태계는 Go 팀과 더불어 커뮤니티 모두에서 풍부한 도구 세트를 보유하고 있다!

이 부록에서는 이러한 도구 중 일부를 소개하고 해당 도구가 개발 전 및 개발 과정, 개발 이후 어떻게 도움을 줄 수 있는지에 대해 설명한다. ==이 책은 동시성에 중점을 두고 있기 때문에 동시 코드를 작성하거나 분석하는 데 도움이 되는 항목만 논의할 것이다.== 또한 고루틴이 패닉에 빠졌을 때 일어나는 일을 간략하게 살펴보겠다. 자주 발생하지는 않지만, 처음 보면 이 출력이 약간 혼란스러울 수 있다.

---
# 고루틴 에러 분석

언젠가는 프로그램에 패닉이 일어날 것이다. 운이 좋다면 그 과정에서 사람이나 컴퓨터에 해를 끼치지 않을 것이며, 최악의 상황은 스택 트레이스의 좋지 못한 결말을 그저 바라보게 되는 것이다.


Go 1.6 이전에는 고루틴이 패닉에 빠지면, 런타임은 현재 실행 중인 모든 고루틴의 스택 트레이스를 출력한다. 때때로 이것은 무슨 일이 일어나는지 판단하는 것을 어렵게 만들었으며, 시간이 걸리게 만드는 요소였다. ==이 글을 쓰는 시점에서, Go 1.6이상은 패닉에 빠진 고루틴의 스택 트레이스만 출력해 작업을 단순화한다.==

예를 들어 다음의 간단한 프로그램을 실행해보자.


``` go
package main

  
func main() {
    waitForever := make(chan interface{})
    go func() {
        panic("test panic")
    }()
    <-waitForever

}
```


프로그램이 패닉 상태일 때 실행 중인 모든 고루틴의 스택 트레이스를 보려면, GOTRACKBACK 환경 변수를 all로 설정하여 예전에 동작 방식을 활성화할 수 있다.


---
### 레이스 탐지

Go 1.1에서는 대부분의 go 명령에 -race 플래그가 플래그로 추가됐다.

``` shell
$ go test -race mypkg # 패키지 테스트
$ go run -race mysrc.go # 프로그램 컴파일 및 실행
$ go build -race mycmd # mycmd 빌드
$ go install -race mypkg # 패키지 설치
```


만약 당신이 개발자이고 레이스 컨디션을 안정적으로 탐지할 방법이 필요한 것뿐이라면 이것만 알면 된다. 레이스 탐지기를 사용할 대 한 가지 주의 사항은, 이 알고리즘은 검사되는 코드에 포함된 레이스 컨디션만 찾는다는 것이다. ==이러한 이유로 Go 팀에서는 실제 환경의 부하 속에서 race 플래그로 빌드된 어플리케이션의 빌드를 실행할 것을 권한다.== 이렇게 하면 더 많은 코드가 실행될 확률이 높아지기 때문에 레이스를 찾을 확률도 높아진다.

보통은 기본값으로 충분하지만, ==환경 변수를 통해 레이스 탐지기의 동작을 조정할 수 있는 옵션도 몇 가지 있다.==

- **LOG_PATH**

레이스 탐지기가 LOG_PATH.pid 파일에 보고서를 쓰도록 지시한다. stdout 및 stderr와 같은 특별한 값을 전달할 수도 있다. 기본값은 stderr이다.


- **STRIP_PATH_PREFIX**

레이스 탐지기가 보고서에서 파일 경로의 시작 부분을 제거해 더 간결하게 만든다.


- **HISTORY_SIZE**

고루틴당 히스토리의 크기, 즉 고루틴 별로 이전의 메모리 접근을 얼마나 기억하고 있을지를 제어한다. 유효한 값 범위는 [0,7]이다. 고루틴 히스토리에 할당되는 메모리는 HISTORY_SIZE가 0일 때 32KB으로 시작해서, 늘어날 때마다 두 배씩 증가해서 HISTORY_SIZE가 7일 때 4MB가 된다. 보고서에서 "failed to restore the stack(스택 복구 실패)"가 표시되면, 이는 이 값을 증가시켜야 한다는 지표이다. 그러나 메모리 소비를 크게 증가시킬 수 있다.

다음은 1장에서 살펴봤던 간단한 예제이다.

``` go
package main

  

import "fmt"

func main() {

    var data int

    go func() { // #1
        data++
    }()

    if data == 0 {
        fmt.Printf("the value is %v. \n", data)
    }

}
```

(실제 실행하면 제대로 작동은 되나 안되는 기준으로 설명하겠다.)

1. 동기화되지 않은 메모리에 접근해 쓰려고 시도하는 고루틴을 나타낸다.


레이스 탐지기는 코드에서 레이스 컨디션을 자동으로 탐지하는 데 매우 유용한 도구이다. 지속적인 통합 프로세스의 일부로 그것을 통합하는 것이 좋다. 다시 한번 말하지만, 레이스 탐지는 발생하는 레이스만 탐지할 수 있기 때문에 레이스 컨디션을 발생시키는 때로는 까다롭기까지 한 방법도 다뤘다. 레이스 컨디션을 일으키기 위해서는 계속해서 실제 시나리오를 실행해야 한다.

---
# pprof

대규모 코드베이스에서는 런타임에 프로그램의 성능을 확인하기가 어려울 수 있다. 얼마나 많은 고루틴들이 돌아가고 있을까? CPU는 완전히 활용되고 있을까? 메모리 사용량을 어떻게 될까? 프로파일링은 이 질문에 대한 훌륭한 답이며, Go는 프로파일러를 지원하기 위해 표준 라이브러리 내에 "pprof"라는 패키지를 가지고 있다.

pprof는 구글에서 만든 도구이며, 프로그램이 실행되는 동안 또는 저장된 런타임 통계를 사용해 프로파일링 데이터를 표시할 수 있다. 이 프로그램의 사용법은 help 플래그에 잘 설명돼 있으므로, 여기에서는 runtime/pprof 패키지, 특히 동시성에 적용되는 부분에 대해 논의한다.

runtime/pprof 패키지는 매우 간단하며, 후킹 및 표시를 위한 프로파일을 미리 정의하고 있다.

- goroutine: 현재의 모든 고루틴들에 대한 스택 트레이스
- heap: 모든 힙 할당에 대한 샘플링
- threadceate: 새로운 OS 스레드의 생성으로 이어진 스택 트레이스
- block: 동기화 기본 요소에서의 대기를 발생시킨 스택 트레이스
- mutex: 뮤텍스를 두고 경합하는 보유자들의 스택 트레이스

동시성의 컨텍스트에서, 이들 대부분은 실행중인 프로그램 내에서 일어나는 일을 이해하는데 유용하다. 다음은 고루틴 누수를 탐지할 수 있도록 도와주는 고루틴의 예제이다.

``` go

package main

  

import (
    "log"
    "os"
    "runtime/pprof"
    "time"
)

  

func main() {  

    log.SetFlags(log.Ltime | log.LUTC)
    log.SetOutput(os.Stdout)

    // 매 초마다 현재 얼마나 많은 고루틴이 실행되고 있는지 기록한다.
    go func() {
        goroutine :=
            pprof.Lookup("goroutine")
        for range time.Tick(1 * time.Second) {
            log.Println("goroutine count:%d \n", goroutine.Count())
        }
    }()

    var blockForever chan struct{}
    for i := 0; i < 10; i++ {
        go func() {
            <-blockForever
        }()
        time.Sleep(500*time.Millisecond)
    }

}
```

이러한 기본 제공 프로파일은 프로그램의 문제점을 프로파일링하고 진단하는 데 정말 도움이 될 수 있지만, 프로그램을 모니터하는 데 도움이 되도록 사용자 정의 프로파일을 작성할 수도 있다.


``` go

package main

  

import (
    "runtime/pprof"
)

  

func newProfIfNotDef(name string) *pprof.Profile {
    prof := pprof.Lookup(name)
    if prof == nil {
        prof = pprof.NewProfile(name)
    }
    return prof
}

func main() {

  

    prof := newProfIfNotDef("my_package_namespace")

}
```
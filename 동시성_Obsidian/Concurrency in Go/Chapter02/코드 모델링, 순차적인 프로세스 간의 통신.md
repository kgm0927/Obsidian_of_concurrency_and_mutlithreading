

### 동시성과 병렬성의 차이

동시성(concurrency), 병렬성(parallelism)과 다르다는 사실을 간과하거나 오해하기 쉽다. 많은 개발자는 업무 중 대화에서도 =="다른 것과 동시에 실행되는 것"==을 표현할 때 종종 동시성과 병렬성을 섞어서 사용한다. 이때 "병렬"이라는 용어를 사용하는 것이 맞는 경우도 있지만, 코드에 대해 토론하는 경우라면 일반적으로 "동시"라는 단어를 사용해야만 한다.


코드를 모델링할 때 동시성과 병렬성의 차이는 객체의 추상화(abstraction)에 큰 영향을 미치는 것으로 밝혀졌으며, Go는 이를 최대한 활용한다. 이 추상화의 효과를 이해하기 위해 두 개념이 어떻게 다른지 살펴보겠다. 

==**동시성은 코드의 속성이고, 병렬처리는 실행 중인 프로그램의 속성이다.**==

보통은 이 둘을 같은 방식으로 생각하지 않는가? 우리는 프로그램이 병렬로 실행되도록 코드를 작성한다. 

한 번 더 생각해보자. 프로그램의 두 부분을 병렬로 실행하려는 의도로 코드를 작성하는 경우, 프로그램이 실행될 대 실제로 그렇게 되리라는 보장이 있는가? 코어가 하나뿐인 기기에서 해당 코드를 실행하면 어떻게 되는가? 병렬적으로 실행될 거라고 생각하겠지만, 사실 그렇지 않다.

프로그램의 각 부분이 병렬로 실행되는 것처럼 보일 수 있지만, 실제로는 구별할 수 없을 정도로 빠르게 순차적으로 실행된다. ==서로 다른 프로그램 간의 시간을 공유하기 위해 CPU의 컨텍스트가 전환되며, 시간을 매우 잘게 쪼개기 때문에 작업이 병렬적으로 실행되는 것처럼 보인다. ==두 코어가 있는 시스템에서 동일한 바이너리를 실행하면, 프로그램의 각 부분이 실제로 병렬로 실행 중일 수 있다. 

이는 몇 가지 흥미롭고 중요한 사실을 암시한다. 첫째, 우리는 병렬적인 코드를 작성하는 것이 아니라, ==병렬로 실행되기를 바라면서 동시성 코드를 작성하는 것이다==. 즉 병렬성은 코드의 속성이 아닌 **프로그램 실행 시의 속성**이다.


둘째, 동시성 코드가 실제로 병렬로 실행되는지 여부를 모를 수도 있다. 심지어 알고자 하는 경우이도 말이다. 프로그램의 모델 아래에 있는 동시성 기본 요소, 프로그램의 런타임, 운영체제 및 하이퍼바이저(hypervisor), 컨테이너(container), 가상 머신(virtual machine)과 같은 운영체제가 실행되는 플랫폼, 그리고 최종적으로 CPU와 같은 추상화 계층들을 통해서만 코드가 병렬로 실행되는지 확인할 수 있다. 이런 추상화로 동시성과 병렬성을 구분할 수 있으며, 궁극적으로 우리 자신을 표현할 수 있는 힘과 유연성을 얻을 수 있다. 

셋째, 병렬 처리인지 아닌지는 시간, 또는 컨텍스트에 의해 결정된다. 컨텍스트의 개념을 논의한 "[[동시성 소개#원자성]]"에 대해서 기억하는가? 어떤 연산을 원자적이라고 판단할 수 있는 범위를 컨텍스트라고 정의했다. ==반면 여기서는 컨텍스트를 두 개 이상의 연산이 병렬적으로 실행됐다고 여길 수 있는 범위로 정의한다.== ^7cae38


시분할(time sclie)의 관점에서 컨텍스트를 재정의하는 것이 그다지 좋지 않을 수도 있지만, 컨텍스트가 시간과 관련된 것만은 아니라는 사실을 기억하자. 컨텍스트 프로그램이 실행되는 프로세스, 또는 해당 프로세스의 운영체제 스레드, 프로세스가 동작하는 장비 등으로 정의할 수 있다. 컨텍스트의 정의는 동시성과 정확성의 개념과 밀접하게 관련된다.
이것이 컨텍스트의 정의가 중요한 이유다. ==원자적인 연산이 정의된 컨텍스트 내에서만 원자적이라고 여겨질 수 있는 것처럼, 동시에 수행되는 작업은 정의된 컨텍스트에서만 정확하다.== 이것은 모두 상대적이다.

컨텍스트가 사용자의 컴퓨터라고 가정하자. 이론적인 물리학을 무시한다면, 하나의 장비에서 실행되는 프로세스가 다른 장비에서 실행되는 프로세스의 로직에 영향을 미치지는 않을 것이라고 합리적으로 기대할 수 있다.

양쪽 모두에서 계산기 프로세스를 시작하고, 간단한 산수 연산을 시작하면 한쪽에서 수행한 계산이 다른쪽에서 수행한 계산에 영향을 주지 않을 것이다.

다소 단순한 예시이기는 하지만, 하나씩 나누어 살펴보면 동시성의 모든 구성 요소를 다루었다. 각각의 컴퓨터는 컨텍스트에 해당하며, 개별 컴퓨터에서 실행되는 프로세스들은 동시에 실행되는 연산에 해당한다. 여기서 동시 연산을 분리된 컴퓨터, 운영체제, 프로세스라는 측면에서 생각하고 모델링하기로 한 것이다. 이런 추상화 덕분에 동시에 실행되는 각 연산이 정확히 수행되리라고 확신할 수 있다.

어떤 두 프로세스가 동일한 분산 시스템에 속하지 않는다고 가정하면, 한 장비의 프로세스가 다른 장비의 프로세스에 영향을 받지 않을 것이라고 예상할 수 있다. 하지만 동일한 장비 내의 두 프로세스가 서로의 논리에 영향을 주지 않을 것이라고 기대할 수 있을까? 프로세스 A가 프로세스 B가 읽고 있는 파일을 덮어 쓸 수 있고, 안전하지 않은 OS에서는 프로세스 A가 프로세스 B가 읽고 잇는 메모리를 침범할 수 있다. 이는 많은 공격 코드(exploit)의 작동 방식이기도 하다.

하지만 여전히 프로세스 수준에서는 컨텍스트를 비교적 쉽게 생각할 수 있다. 계산기 예제로 돌아가면, ==동일한 장비에서 두 개의 계산기 프로세스를 실행하는 두 명의 사용자는 자신의 작업이 논리적으로 서로 격리될 것으로 예상하는 것이 합리적이다==. 다행히도 **프로세스 경계**(process boundary)와 운영체제는 논리적인 방식으로 동시성 문제들을 생각하는데 도움이 된다. 그러나 개발자는 동시성에 대한 우려로 부담을 느끼기 시작하며, 이러한 부담은 점점 심해질 수 있다.


OS 스레드 경계로 한 단계 더 내려가면 어떻게 될까? 바로 이 지점에서 [[동시성 소개#동시성이 어려운 이유]]절에서 레이스 컨디션, 데드락, 라이브락, 기아 상태와 같이 모든 문제가 실제로 발생한다. 같은 장비를 사용하는 모든 사람들이 하나의 계산기 프로세스만 바라보고 있다면 동시성 로직을 제대로 동작하게 하는 것이 더 어려울 것이다. 메모리 접근에 대한 접근을 동기화하고, 정확한 사용자가 정확한 결과를 조회하는지 신경써야 한다.


추상화 단계가 진행될수록 무언가를 동시적으로 모델링하는 문제는 더욱 추론하기 어려워지고 중요해진다. 거꾸로 동시적으로 모델링하는 문제가 어려워질수록 추상화는 더욱 더 중요하다. 다시 말해 동시성을 제대로 확보하는 것이 어려우면 어려울수록, 사용이 용이한 동시성 기본 요소(primitive)들에 접근할 수 있는지가 중요하다는 것이다. 그러나 불행히도 업계의 대부분의 동시성 논리는 가장 높은 추상화 수준인 OS스레드에서 작성돼 있다.

Go가 처음으로 공개되기 전에, 인기 있는 프로그래밍 언어 대부분의 추상화 체인은 OS 스레드에서 끝났다. 동시성 코드를 작성하면 스레드의 관점에서 프로그램을 모델링하고, 이들 사이의 메모리 접근을 동기화해야 한다. 동시적으로 모델링해야 하는 작업이 많고, 시스템이 많은 스레드를 처리할 수 없을 때는 스레드 풀(thread pool)을 만들고 스레드 풀에 작업을 다중화해야 했다.

Go는 이 체인에 또 다른 연결 고리인 고루틴을 추가했다. 또한 Go는 유명한 컴퓨터 과학자인 안토니 호어의 작업에서 몇 가지 개념을 차용해, **채널**(channel)을 사용하는 새로운 기본 요소를 도입했다.


지금까지 추론해온 방향대로라면, OS 스레드 아래에 또 다른 추상화 수준을 도입하는 경우 상황이 어려워질 거라고 추측할 수 있겠지만, 사실은 그렇지 않다. 실제로는 더 쉬워진다. ==실제로 OS 스레드 위에 또 다른 추상화 레이어를 추가하는 것이 아니라 그것을 대체했기 때문이다.==


스레드는 여전히 존재하지만, OS 스레드라는 관점에서 문제 공간을 생각할 필요가 거의 없다는 사실을 알게 될 것이다. 대신 고루틴과 채널에서 모든 것을 모델링하며 때때로 메모리를 공유한다. 이는 나중에 앞에 [[동시성을 지원하는 언어의 장점]]에서 살펴볼 흥미로운 속성과 같은 맥락이다. 하지만 먼저 Go의 아이디어를 상당 부분 가져온 논문이자, Go의 동시성 기본 요소의 뿌리가 되는 찰스 안토니 리차드 호어의 세미나 논문인 "상호작용하는 순차적 프로세스들"(Communicating Sequential Processes)을 자세히 살펴본다.


---

### CSP란 무엇인가?

Go에 대해 논의를 하면 종종 CSP라는 약자를 듣게 된다. CSP 덕분에 Go가 성공했다고 극찬하는 경우가 있으나, CSP는 이러한 작업을 더 쉽게 해주고 프로그램을 더 견고하게 만들어주지만, 모든 것을 해결해 주진 않는다.


CSP는 "상호작용하는 순차적 프로세스들(Communicating Sequential Processes)"의 약자로 그 자체가 논문의 제목이자 여기에서 소개하는 기법의 이름이다. 1978년 찰스 안토닌 리차드 호어는 미국 계산기 학회(ACM)에서 이 논문을 발표했다.

논문에선 "프로그래밍에서 두 가지 기본 요소인 입력 및 출력이 간과되어 있으며, 특히 동시에 실행되는 코드의 경우에는 더더욱 그렇다"고 말한다. 호어가 이 논문을 집필할 단시 프로그램을 구조화하는 방법에 대한 연구는 여전히 진행되고 있었지만, 연구들 중 대부분은 코드를 위한 기법에 관한 것이었다. 당시에는 goto 문법의 사용이 논의되고 있었고, 객체 지향 패러다임이 싹트기 시작했다. 동시성 연산에 대해서는 고려하지 않았다. 호어가 이를 바로잡으면서 CSP가 탄생했다.

실제로 호어는 그의 논문에서 소개한 개념과 표기법이 추상적이며, 실제적인 프로그래밍을 위한 프로그래밍 언어로 사용하기에는 적합하지 않다고 말했다.

호어는 자신이 제안한 기술이 프로그램의 정확성을 밝혀내는 데 아무런 도움이 되지 않고, 자신이 제안한 기술에 대한 언어가 실질적인 성능을 내지 못할까봐 깊이 우려를 했다. 이후 6년 동안, ==CSP의 개념은 "상호작용하는 순차적 프로세스들"이라는 개념과 결합해서, 프로그램의 정확성을 입증하는 연구를 통해 **프로세스 미적분/대수**(process calcalus/process algebras)라는 형식 표현법(formal representation)으로 발전했다.== 

프로세스 미적분이란, 동시성 시스템을 수학적으로 모델링하는 방법으로, 이한 시스템들을 대상으로 여러 가지 변형을 수행해 효율성 및 정확성과 같은 다양한 속성을 분석하는 대수적 법칙을 제공한다. 프로세스 미적분은 그 자체로도 흥미로운 주제지만 이 책의 범위를 벗어난다. CSP에 대한 최초의 논문과 그로부터 진화된 언어가 Go의 동시성 모델에 크게 영감을 주었기 때문에, 이제부터는 여기에 중점을 둘 것이다.


호어는 입력과 출력이 언어 기본 요소로 간주돼야 한다는 주장을 뒷받침하기 위해, 그의 CSP 프로그래밍 언어에 프로세스 간 입력 및 출력, 즉, 통신을 정확하게 모델링하기 위한 기본 요소들을 포함시켰다. 호어의 논문 제목이 바로 이 통신에서 유래했다. 호어는 입력을 요구하고 다른 프로세스가 사용할 출력을 생산하는 로직의 캡슐화된 부분을 **"프로세스"** 라고 지칭했다. 호어가 논문을 집필할 당시에 업계에서 프로그램을 어떻게 구조화할 것일지에 대한 논쟁이 없었다면 "프로세스" 대신 "함수"(function)라는 용어를 사용했을지도 모른다.

호어는 프로세스 사이의 통신을 위해 입력 및 출력 명령을 만들었다. ==!는 프로세스에 입력을 보내기 위한 것이고==, ==?는 프로세스에서 출력을 읽어오기 위한 것이다.== 각 명령은 프로세스의 바깥에서 변수를 읽는 경우 출력 변수를, 프로세스로 입력을 보내는 경우는 목적지를 지정해야 한다.

때로는 이 두 가지가 동일한 것을 가리키는 경우도 있는데, 이 경우는 두 프로세스가 상응(correspond)한다고 말한다. 즉, 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달되는 경우다. 

[[표 2-1]]는 이 논문에 나오는 몇 가지 예제를 보여준다.

Go의 채널과 유사하다는 것을 알 수 있다. 마지막 예제에서 west의 출력이 변수 c로 보내지고, 동일한 변수에서 east의 입력으로 수신되는 방법에 주목하자. 이 두 프로세스는 상응하는 프로세스이다. 호어의 CSP에 대한 첫 번째 논문에서, 프로세스는 이름이 지정된 출처(source)와 목적지(destination)를 통해서만 통신할 수 있었다.

그는 코드를 라이브러리를 포함시킬 때 코드를 가져다 쓰는 쪽(consumer)에서 입력과 출력의 이름을 알아야 하기 때문에 문제가 있음을 알고 있었다. 그는 소비자 측에서 입출력의 이름을 알 수 있도록 하기 위해 "포트 이름"(port name)이라고 불렀던 것을 등록할 수 있다고 언급했는데, 이 이름은 병렬 명령의 앞 부분(head)에 선언할 수 있었으며 이름이 지정된 매개 변수와 이름이 지정된 리턴 값으로 인식될 수 있다.

이 언어는 또한 1974년, 에드가 다익스트라(edgar Dijkstra)의 논문 "보호받는 명령어, 프로그램의 비결정성 및 형식 유도"(Guarded commands, nondeterminacy and formal derivation of programs)이라는 논문에서 언급된, 소위 보호받는 명령(guarded command)에서도 사용됐다.

보호받는 명령어는 왼쪽과 오른쪽 부분이 ->로 나뉘어진 구문이다. 왼쪽 부분은 조건 또는 오른쪽 부분에 대한 보호 장치로서, 왼쪽 부분이 거짓(false)이거나, 거짓을 리턴하는 명령어이거나, 종료(exit)된 경우에 오른쪽 부분은 절대 실행되지 않는다. 이 개념들을 호어의 I/O 명령과 결합하면 호어의 상호 통신하는 프로세스의 기초가 되며, 곧 Go 채널의 기반이 된다.


이러한 기본 요소를 사용해, 호어는 통신을 모델링하기 위한 일급(first-class) 지원 언어가 문제를 얼마나 더 간단하고 이해하기 쉽게 해주는지에 대한 몇 가지 예제들을 보여줬다. 그가 사용하는 표기법 중 일부는 지나칠 정도로 간결하다. 그러나 호어가 제시한 문제는 매우 명확한 해결책을 지니고 있다. Go가 제시한 비슷한 해결책도 이보다는 조금 더 길지만 명확성을 지니고 있다.

역사는 호어의 제안이 정확하다고 보았다. 그러나 Go가 발표되기 전까지는 극 소수의 언어들만 이런 기본 요소를 언어 내적으로 지원했다는 점이다. 인기있는 언어 대다수는 CSP의 메시지 전달 스타일보다 메모리에 대한 접근을 공유하고 동기화하는 방식을 선호한다. 예외도 있지만, 유감스럽게도 이 기능들은 그다지 인기가 없는 언어들만 보유하고 있다.

Go는 CSP에 핵심 원칙을 통합한 최초의 언어 중 하나로, 동시성 프로그래밍 스타일을 대중에게 제공한다. Go가 성공을 거두두면서 다른 언어도 이런 기본 요소를 추가하려고 시도하게 됐다.

메모리 접근 동기화가 본질적으로 나쁜 것은 아니다. 뒤이어 "[[Go의 동시성에 대한 철학]]"의 뒷부분에서 배우겠지만, Go에서조차도 특정 상황에서의 메모리를 공유하는 것이 더 적절하다는 것을 알 수 있다. 그러나 공유 메모리 모델은 특히 대규모 프로그램이나 복잡한 프로그램에서 올바르게 사용하기 어려울 수 있다. 동시성이 Go의 강점 중 하나로 간주되는 이유가 그것이다. 처음부터 CSP의 원칙을 염두에 두고 구축됐으므로 쓰기 쉽고, 추론하기 쉽다.


---

### 동시성을 지원하는 언어의 장점

동시성을 지원하기 위한 기본 요소라는 개념과 이를 구현한 언어를 비롯한 이 모든 것을 매력적으로 생각할 수도 있고, 그렇지 않을 수도 있지만, 이 책을 읽고 있다면 동시성에 관해 해결해야 할 문제가 있으며 이것이 중요한 이유가 궁금할 것이다. Go가 동시성과 관련해 다른 대중적인 언어와 차별화되는 점은 무엇일까?


동시성 문제를 모델링하기 위해 "[[동시성과 병렬성]]"에서 논의했듯이, 많은 언어는 보통 OS 스레드 및 메모리 접근 동기화 수준에서 언어의 추상화 체인을 끝낸다. Go는 다른 방식을 사용해 고루틴 및 채널의 개념으로 이를 대체한다.

동시성 코드를 추상화하는 ==두 방법의 개념을 비교해보면 고루틴은 스레드와==, ==채널은 뮤텍스와 비교할 수 있을 것이다== (이러한 기본 요소들이 매우 유사해 보이기는 하지만, 비교해보면 각각의 상황을 파악하는 데 도움이 될 것이다). 이 추상화가 우리에게 가져다주는 장점은 무엇인가?

고루틴은 병렬성이라는 측면을 고민할 필요가 없도록 도와주며, 대신 본연의 동시성 수준에 가깝게 문제를 모델링할 수 있도록 해 준다. 동시성과 병렬성의 차이점을 살펴봤지만, 해결책을 모델링하는데 병렬성을 고민할 필요가 없이 동시성을 지원한다는 차이가 어떻게 영향을 미치는지 명확하지 않다. 

예를 들어 보겠다.

엔드 포인트에서의 요청을 처리하는 웹 서버를 빌드해야 한다고 가정해보자. 잠시 프레임워크를 스레드 추상화만을 제공하는 언어로 설정한다면, 아마도 다음 질문에 대해 심사숙고하게 될 것이다.

- 이 언어가 자체적으로 스레드를 지원하는가? 아니면 라이브러리를 선택해야 하는가?
- 스레드의 제한 영역은 어디에 있어야 하는가?
- 이 운영체제의 스레드는 얼마나 무거운가?
- 프로그램이 동작하는 운영체제는 스레드를 어떻게 다르게 처리하는가?
- 생성하는 스레드의 수를 제한하기 위해 작업자 풀을 만들어야 한다. 최적의 개수는 어떻게 알 수 있을까?

이 모든 질문은 중요하지만, 어떤 질문도 해결하려는 문제와 직접 관련이 있는 건 아니다. 병병렬성 문제를 어떻게 해결할 것인지 대한 세부적인 난관에 바로 빠져들고만 것이다.


한 발 뒤로 물러나서 원래의 문제를 생각한다면 다음과 같이 기술할 수 있다. 개인 사용자가 내 엔드 포인트에 연결하고 세션을 연다. 세션은 요청을 내보내고 응답을 리턴해야 한다. Go에서는 코드상에서 이런 문제의 본질적인 상태를 거의 직접적으로 표현할 수 있다. ==들어오는 연결마다 고루틴을 만들고, 거기게 요청을 입력한 다음(데이터 및 서비스를 위해 다른 고루틴과 통신할 수 있다), 고루틴의 함수에서 리턴한다.== 이처럼 문제에 대해 자연스럽게 생각하는 방식이 Go에서 자연스럽게 코딩하는 방식으로 연결된다.

Go는 다음과 같이 약속한다. 고루틴은 가볍기 때문에 고루틴 생성을 걱정할 필요는 없다. 시스템에서 얼마나 많은 고루틴이 생서되고 있는지 고려해야 할 적절한 시점이 있기는 하지만, 너무 빨리 고민하는 것은 성급한 최적화이다. 이 문제를 사전에 고려하는 편이 현명하다고 할 수 있는 스레드와 비교해보자.

어떤 언어에서 병렬성 문제를 추상화할 수 있는 프레임워크가 존재한다고 해서, 동시성 문제를 모델링하는 본연의 방법이 중요하지 않다는 의미가 아니다! ==누군가는 프레임워크를 작성해야 하며, 작성자가 처리해야 하는 복잡성이 무엇이든지 간에 당신의 코드는 최상단에 위치할 것이다. 단지 복잡성이 숨겨져 있다고 해서 그것이 존재하지 않는다는 것을 의미하지는 않으며, 복잡성은 버그를 낳는다.== Go는 동시성을 중심으로 설계됐기 때문에, 이 언어가 제공하는 동시성 기본 요소에는 해당하지 않는 이야기다. 즉 함수의 개수도 적고 더 버그도 적다는 의미이다!

문제 공간에 대한 보다 자연스러운 매핑은 엄청난 이점이지만, 여기에 더해 몇 가지 유익한 이점도 얻을 수 있다. ==Go의 런타임은 고루틴을 OS 스레드에 자동으로 다중화하고 스케줄링을 관리해준다.== ==이는 문제를 모델링한 방법을 변경하지 않고도 런타임을 최적화할 수 있다는 것을 의미한다.==이것은 **고전적인 관심사 분리**(seperation of concerns)이다. 병렬 처리가 발전할수록 Go의 런타임은 개선될 것이며 프로그램의 성능이 향상될 것이다.


Go의 릴리즈 정보를 주의 깊게 살펴보자. 다음과 같은 문구를 볼 수 있다.

` Go 1.5에서는 고루틴의 스케줄링 순서가 변경됐다.`


Go의 작성자는 프로그램을 더 빠르게 만들기 위해 보이지 않는 곳에서 기능을 개선 하고 있다.


동시성과 병렬성의 분리는 또 다른 장점이다. Go의 런타임이 고루틴의 스케줄링을 관리해주기 때문에 고루틴이 I/O를 기다리면서 멈춰 있는지 검사할 수 있고, 고루틴에 멈춰 있지 않은 OS 스레드를 지능적으로 재할당할 수 있다. 이 또한 코드 성능을 향상시킨다. Go의 런타임은 6장에서 다룰 것이다.

문제 공간과 Go 코드 간의 보다 자연스러운 매핑으로 인한 또 다른 이점은, 동시성 방식으로 모델링된 문제 공간의 양이 늘어난다는 것이다. 개발자인 우리가 다루는 문제들은 자연적으로 동시적인 경우가 그렇지 않는 경우보다 많다. 따라서 자연스럽게 다른 언어보다 세분화된 수준으로 동시성 코드를 작성할 것이다. 예를 들어, 웹  서버 예제로 돌아가면 스레드 풀에 다중화된 연결을 사용하는 대신 모든 사용자가 각각의 고루틴을 가지게 된다. ==이 섬세한 수준의 세분화로 인해 프로그램은 자신의 호스트에서 허용하는 병렬성의 양만큼 **동적으로** 확장될 수 있으며== , 이는 암달(Amdahl)의 법칙이 실제로 적용된 문제라고 할 수 있다! 이것은 놀라운 일이다.

고루틴은 퍼즐의 일부분에 불과하다. CSP의 다른 개념인 채널과 select 역시 가치를 더해준다.


예를 들어, 채널은 본질적으로 다른 채널들과 **구성 가능하다.** 출력들을 손쉽게 구성함으로써 여러 하위 시스템으로부터의 입력을 조정할 수 있기 때문에, 대형 시스템을 더 간단하게 작성할 수 있다. 입력 채널을 제한 시간(timeout), 취소 또는 다른 하위 시스템으로의 메시지와 결합할 수 있다. 뮤텍스 조정은 훨씬 더 어려운 문제이다.


select 구문은 Go의 채널을 보완하며, 채널 구성의 모든 어려운 부분을 가능하게 해 준다. select문을 사용하면 효율적으로 이벤트를 기다리거나, 경재 채널 사이에서 균등 난수(uniform random)방식으로 메시지를 선택하거나, 대기 중인 메시지가 없는 경우에 계속 진행할 수 있다.

CSP에서 영감을 얻은 기본 요소들과 이를 지원하는 런타임의 화려한 조합이 Go에 가장 강력한 힘을 선사한다. 이 책의 뒷부분에서 이런 Go의 기능이 어떻게 작동하는지, 멋진 코드를 작성할 대 왜 Go를 사용해야 하는지, 또 어떻게 사용해야 하는지를 배운다.


---

### Go의 동시성에 대한 철학


Go의 많은 부분이 CSP를 중심으로 설계됐으며, 현재도 그러하다. 그러나 Go는 메모리 접근 동기화를 비롯한 여러 가지 전통적인 동시성 코드 작성 방법 역시 지원한다. sync 및 기타 패키지들의 구조체와 메서드를 사용하면, 잠금을 수행하고 리소스 풀을 만들고, 고루틴을 선점하는 등의 작업을 할 수 있다.

CSP 기본 요소와 메모리 접근 동기화 중에서 선택할 수 있기 때문에 문제를 해결하기 위해 동시성 코드를 어떤 스타일로 작성할지 조금 더 통제할 수 있다는 장점이 있지만, 약간의 혼란이 올 수 있다. Go 언어를 새롭게 접한 사람들은 종종 CSP 스타일이 Go에서 동시성 코드를 작성하는 유일한 방법으로 여겨지고 있다는 인상을 받는다. 그 예로, 다음과 같이 sync 패키지의 문서의 내용을 살펴보자.

`sync 패키지는 상호 배타 잠금(mutual exclusion lock) 같은 기초적인 동기화 기본 요소를 제공한다. Once와 WaitGroup 타입을 제외하면, 대부분은 저수준을 라이브러리 루틴에서 사용하기 위한 것이다. 채널 및 통신을 통해 보다 높은 수준의 동기화를 수행할 수 있다.`

이 언어의 FAQ에는 다음과 같은 내용이 있다.

`sync 패키지가가 뮤텍스를 구현하기는 하지만 Go 프로그래밍 스타일을 통하여 사람들이 더 높은 수준의 기법을 시도하도록 유도할 수 있기를 바란다. 특히 한 번에 하나의 고루틴만 특정 데이터에 대한 책임을 지도록 프로그램을 구성하는 것을 고려해보라.`

메모리 공유를 사용해 통신하지 마라. 대신 통신을 통해 메모리를 공유하라.


이 밖에도 Go 팀의 여러 구성원이 sync.Mutex와 같은 기본 요소 대신 CSP 스타일을 사용할 것을 주장하는 기사나 강의, 인터뷰도 많이 찾아볼 수 있다.

그러니까 도대체 왜 Go 팀이 메모리 접근 동기화 기본 요소를 공개하기로 했는지 모르겠다고 해도 충분히 공감할 수 있다. 훨씬 더 혼란스러울 수 있는 부분은, 이러한 메모리 접근 동기화 기본 요소들이 일반적으로 실무에서 눈에 띌 뿐만 아니라, 사람들이 Go로 프로그램을 작성하는 과정에서 채널을 과도하게 사용하는 것에 대한 불평 역시 볼 수 있으며, Go 팀원 중 일부는 메모리 접근 동기화 기본 요소를 사용해도 괜찮다고 말한다는 점이다. 다음은 Go 위키에서 인용한 것이다.

`Go의 모토 중 하나는 "통신을 통해 메모리를 공유하고, 메모리 공유를 통해 통신하지 말라"이다. 즉, Go는 sync 패키지에서 전통적인 잠금 메커니즘을 제공한다. 대부분의 잠금 문제는 채널이나 전통적인 잠금 중 하나를 사용해 해결할 수 있다.`

그렇다면 어느 쪽을 사용해야 할까?

가장 표현력이 풍부하면서 가장 단순한 것, 또는 둘 중 하나에 해당하는 것을 사용하라.

이는 좋은 조언이며, Go로 작업할 때 자주 볼 수 있는 지침이지만 다소 모호하다. ==더 표현법이 풍부하면서 단순한 것, 또는 양쪽 중 하나에 해당하는 것이 무엇인지 어떻게 알 수 있을까?== 어떤 기준으로 판단해야 할까? 다행히도 제대로 판단할 수 있도록 도와주는 몇 가지 지침이 있다. 뒤에서 알게 되겠지만, 가장 확실하게 구분할 수 있는 기준은 내부적으로는 매우 좁은 범위(scope)에서, 외부적으로는 시스템 전체에 이르기까지, 동시성을 관리하려고 하는 위치이다. **그림 2-1** 이러한 지침을 **결정 트리**(decision tree)로 나열한다.


그림 2-1 결정 트리

[그림]


결정 지점을 하나씩 따라가보자.

- 데이터의 소유권을 이전하려고 하는가?

결과를 산출하는 약간의 코드가 있고, 그 결과를 또 다른 코드와 공유하려는 경우, 실제로 수행하는 작업은 해당 데이터의 소유권을 이전하는 것이다. 가비지 컬렉션을 지원하지 않는 언어에서의 메모리-소유권(memory-ownership) 개념에 익숙할지 모르겠는데, 이것은 그 개념과 동일하다. 데이터는 하나의 소유자가 있으며, 동시에 실해되는 프로그램들을 안전하게 하는 방법은 한 번에 하나의 동시 컨텍스트만 데이터의 소유권을 가지게 하는 것이다. 채널은 한 번에 하나의 동시 컨텍스트만 데이터 소유권을 가저야 한다는 의도를 채널의 타입에 인코딩함으로써 메모리 소유권 개념을 전달할 수 있게 해 준다.


이 방식의 가장 큰 장점은, 적은 비용으로 메모리 내부 큐(in-memory queue)를 구현하기 위해 버퍼링 채널을 생성하고, 이를 통해 생상자와 소비자를 분리할 수 있다는 점이다.

또 다른 장점으로는, 채널을 이용하면 여러분의 동시성 코드를 다른 동시성 코드와 함께 구성할 수 있다는 점이다.


- 구조체의 내부 상태를 보호하고자 하는가?

구조체의 내부 상태를 보호해야 하는 상황은 메모리 접근 동기화 기본 요소를 사용할 수 있는 훌륭한 후보로, 채널을 사용해서는 안 된다는 매우 강력한 지표이다. ==메모리 접근 동기화 기본 요소를 사용하면 임계 영역을 잠그는 구현의 세부 사항을 호출자에게 공개하지 않을 수 있다.== 다음은 스레드에는 안전(thread-safe)하지만 호출자에게는 그 복잡성을 드러내지 않는 타입의 간단한 예제이다.


``` go

type Counter struct{
mu sync.Mutex
value int
}

func (c *Counter)Increment(){
c.mu.Lock()
defer c.mu.Unlock()
c.value++
}

```

원자성의 개념을 상기해보면, 여기에서 수행한 작업이 Counter 타입의 원자성 범위로 정의된다고 말할 수 있다. Increment에 대한 호출은 원자적이라고 간주할 수 있다.

여기서 핵심이 되는 단어는 "내부적"이라는 것을 잊지 말자. 어떤 타입을 넘어서 잠금이 드러나는 것을 발견하면 경계해야 한다. 잠금을 작은 어휘 범위(lexical scope)로 제한해보자.


- 여러 부분의 논리를 조정해야 하는가?

채널은 본질적으로 메모리 접근 동기화 기본 요소보다 더 쉽게 구성 가능하다는 것을 기억하자. ==객체 그래프상에 흩어져 있는 잠금들은 끔찍하지만, 채널은  객체 그래프상의 어디에든 있을 수 있으며, 채널을 가지고 있을 것을 권장한다==! 채널은 구성할 수 있지만, 값을 리턴하는 잠금이나 메서드는 쉽게 구성할 수 없다. 


채널을 사용한다면, Go의 대기열로 제공되면 안전하게 전달해주는 채널의 기능과 select 문 덕분에 소프트웨어에서 발생하는 긴급한 복잡성을 훨씬 쉽게 제어할 수 있다. 동시성 코드가 작동하는 방식, 데드락 또는 레이스가 발생하는 이유, 기본 요소를 사용하는 방식을 이해하는데 어려움을 겪는다면 이런 장점이 채널을 사용해야 하는 신호일 것이다.


- 성능상의 임계 영역(performance-critical section)인가?


이 질문이 "내 프로그램이 성능이 뛰어나기를 바란다. 그러므로 뮤텍스만을 사용할 것이다"라는 의미는 절대 아니다. ==오히려 특정 프로그램 영역에 대한 성능을 분석한 결과, 해당 영역이 프로그램의 나머지 부분보다 현저하게 느린 주요 병목 지정으로 밝혀졌다면, **메모리 접근 동기화 기본 요소**를 사용하자.== 이 임계 영역이 부하 상황에서 동작하는데 도움이 될 수 있다. 그 이유는, 채널이 동작할 때 메모리 접근 동기화를 사용하기 때문에 채널이 더 느릴 수 있기 때문이다. 그러나 이 방식을 고려하기 전에, 성능상의 임계 영역은 프로그램을 재구성해야 한다는 사실을 암시하고 있을 수도 있다.

부디 이 기준을 통해 CSP 스타일의 동시성과 메모리 접근 동기화 중에 어떤 것을 사용할지 분명히 결정했기를 바란다. ==개발자들이 동시성을 추상화하는 수단으로 OS 스레드를 사용하는 언어를 사용할 때 자주 보이는 패턴과 관행들이 있다.== **스레드 풀**이 그 예다.

이런 추상화의 대부분이 OS 스레드의 강점과 약점을 대상으로 하기 때문에, Go로 작업할 때는 이런 패턴을 사용하지 않은 편이 좋다. 그렇다고 해서 이들 패턴이 쓸모없다는 의미는 아니지만, Go에서는 그 용례가 훨씬 제한적이다. ==계속해서 고루틴을 사용해 문제 공간을 모델링하고, 작업 중 동시에 수행되는 부분을 표현하기 위해 고루틴을 사용하자.== 그리고 두려워하지 말고 마음편히 고루틴을 수행하자. 하드웨어가 지원할 수 있는 고루틴 수의 상한에 도달하기 전에 프로그램을 재구성해야 할 가능성이 훨씬 더 크다. 

**동시성에 대한 Go의 철학은 다음과 같이 요약할 수 있다. 단순화를 목표로 하고, 가능하면 채널을 사용하며, 고루틴을 무한정 쓸 수 있는 자원처럼 다루어라.**
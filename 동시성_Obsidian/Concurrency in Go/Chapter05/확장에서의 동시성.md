
이제 Go에서 동시성을 활용하는 일반적인 패턴을 배웠으므로, 이러한 패턴들을 실제로 구성해 크고 구성 가능하면서도 확장할 수 있는 시스템을 작성해보자.

5장에서는 단일 프로세스 내에서 동시 작업의 규모를 조정하는 방법을 논의하고, 둘 이상의 프로세스를 처리할 때 동시성이 어떻게 작용하는지 살펴본다.

---

# 에러 전파


동시 코드, 특히 분산 시스템을 사용하면 시스템에서 문제가 발생하기 쉽고, 문제의 원인을 쉽게 파악할 수 없다. 시스템 전반에 걸쳐 문제가 전파되는 방식과 최종 사용자가 어떻게 대처해야 하는지를 신중하게 고려해야 자신이나 팀, 또는 사용자의 고통을 덜어줄 수 있다.

143 페이지의 "[[Go의 동시성 패턴#에러처리|에러 처리]]"에서 고루틴에서 에러를 전파하는 방법은 논의했지만, 그러한 에러가 어떤 모습이어야 하는지나, 크고 복잡한 시스템에서 에러가 어떻게 전달돼야 하는지에 대해서는 이야기하지 않았다. 이번에는 에러 전파의 철학에 대해 논의해보자. 다음은 동시성 시스템에서 에러를 처리하기 위한 독창적인 프레임워크다.

많은 개발자가 에러 전파가 시스템의 흐름에서 부수적이거나 "별개"의 요소라고 생각하는 실수를 범한다. 데이터가 시스템을 통해 흘러가는 방법에 대해서는 신중하게 고려하지만, 에러는 별다른 생각없이 용인되고 불시에 스택을 빠져나가 결국은 사용자 앞에 버려지는 것이다.

Go는 사용자가 호출 스택의 모든 프레임에서 에러를 처리하도록 강요함으로써 이 나쁜 습관을 고치려고 시도했지만, 시스템의 제어 흐름이 에러를 2등 시민으로 간주하는 것은 흔한 일이다. 조금만 미리 고민하고 최소한의 부담만 감수하면 에러 처리를 시스템의 자산으로 만들고 사용자에게 즐거움을 줄 수 있다.

먼저 에러가 무엇인지 살펴보자. 언제 에러가 발생하며, 에러를 통해 얻는 이점은 무엇일까?

==**에러**는 시스템이 사용자가 명시적으로 또는 암시적으로 요청한 작업을 수행할 수 없는 상태에 들어갔음을 나타낸다.== 이 때문에 에러는 몇 가지 중요한 정보를 전달해야 한다.


- 발생한 사건

이것은 **"디스크가 가득 찼다"**,**"소켓이 닫혔다"** 또는 **"자격이 만료되었다"** 와 같은 정보를 포함한 에러의 유형이다. 이 정보는 에러를 발생시킨 것이 무엇이든 간에 암시적으로 생성될 수 있으며, 사용자에게 도움이 될 만한 컨텍스트를 추가시킬 수 있다.


- 발생한 장소 및 시점

==에러에는 항상 호출이 시작된 메서드부터 시작해 에러가 인스턴스화된 위치로 끝나는 전체 스택 트레이스가 포함돼야 한다.== 스택 트레이스가 에러 메시지에 포함돼서는 안 되지만(이에 대해서는 잠시 후에 다룬다), ==스택 위쪽에 에러를 처리할 때는 쉽게 접근할 수 있어야 한다.==

또한 에러에는 실행 중인 컨텍스트와 관련된 정보가 포함돼야 한다. 예를 들어, ==분산 시스템에서는 에러가 발생한 시스템을 식별할 수 있는 방법이 있어야 한다.== 나중에 시스템에서 발생한 일을 이해하려고 할 때 이 정보는 매우 중요하다.


- 사용자 친화적인 메시지

==사용자에게 표시되는 메시지는 시스템 및 시스템의 사용자에 맞춰 조정해야 한다.== 이때 앞의 두 가지에 대한 간략하면서도 유의미한 정보만을 포함해야 한다. 친화적인 메시지는 인간 중심적이면서 문제가 일시적인지 여부를 알려주는 한 줄 정도의 문구여야 한다.

- 사용자가 추가적인 정보를 얻을 수 있는 방법

어떤 시점에서 누군가는 에러가 발생했을 때 일어난 일을 자세히 알고 싶어 할 것이다==. 사용자에게 표시되는 에러는 에러가 기록된 시간이 아닌 에러의 발생시간, 에러가 생성됐을 때의 전체 스택 트레이스 등 에러의 전체 정보를 표시하는 로그에 상호 참조될 수 있는 ID를 제공해야 한다.== 또한 버그 추적 시스템에서 비슷한 문제를 집계하는 데 도움이 되는 스택 트레이스의 해시 값을 포함하는 방식도 유용할 수 있다.


기본적으로 아무런 개입 없이 이러한 정보가 모두 에러에 포함되지는 않는다.

따라서 이런 정보 없이 사용자에게 전파되는 에러는 실수이며 버그라 할 수 있다. 이 문제를 해결하기 위해 에러에 대해 생각할 수 있는 범용적인 프레임워크에 대해 고민할 필요가 있다. 모든 에러는 다음 두 가지 범주 중에 하나로 분류할 수 있다.

- 버그
- 알려진 예외적인 경우(예: 네트워크 연결 단절, 디스크 쓰기 실패 등)

==**버그**는 사용자가 **시스템에 맞춰 정의하지 않는 에러** 또는 "**처리되지 않은(raw)**"에러다.== 때로는 의도적인 경우도 있다. 시스템 출시 후 처음 몇 번의 반복 동안은 이미 알려진 예외에 해당하는 에러를 사용자에게 알릴 수도 있었다. **때로는 버그가 우연히 발생하기도 한다.** 그러나 여기서 제시한 접근법에 동의한다면, 처리되지 않은 에러는 항상 버그다. 이렇게 구분하면 에러를 전파하는 방법, 시간이 지남에 따라 시스템을 확대하는 방법 및 최종적으로 사용자에게 표시할 내용을 결정할 때 유용하다.

여러 개의 모듈을 가진 대형 시스템을 상상해보자.

``` mermaid
flowchart LR

node1(CLI 구성요소)-->node2(중개자 구성 요소)-->node3(하위 구성 요소)
```

그리고 "하위 구성 요소"(Low Level Component)에서 에러가 발생했고 올바른 형식(well-formed)의 에러를 만들어 스택의 위쪽에 전달했다고 가정해보자. ==**"하위 구성 요소"** 컨텍스트에서 이 에러는 올바른 형식으로 간주될 수 있지만, 시스템의 컨텍스트 내에서는 그렇지 않을 수도 있다.== 각 구성 요소의 경계에서, 들어오는 모든 에러는 코드가 포함된 구성 요소에 올바른 형식의 에러로 포장돼야 한다는 입장을 취해보자. 예를 들어 **"중개자 구성 요소"**(Intermediary Compnent)에서 **"하위 구성 요소"** 의 코드를 호출했을 때 에러가 발생했을 수 있다.

``` go
func PostReport(id string) error{
result,err:=lowlevel.DoWork()

if err !=nil{
  if _,ok:=err.(lowlevel.Error);err{ // #1
  err=WrapErr(err,"cannot post report with id %q",id) // #2
  }
return err

}
// ..
}
```

1. 여기서는 올바른 형식의 에러를 받았는지 확인한다. 그렇지 않은 경우 버그를 나타내기 위해 잘못된 형식의 에러를 스택의 위쪽으로 전달한다.
2. 여기서는 가상 함수를 호출해 전달받은 에러를 모듈에 대한 정보와 함께 포장하고 새로운 타입을 부여한다. 에러를 감싸는 것은, 이 컨텍스트 내에서 사용자에게 중요하지 않을 수 있는 저수준의 세부 정보를 숨기는 것이 포함될 수 있다.

==에러가 발생한 근본적인 원인이 어디인지에 대한 세부 정보(예: 고루틴, 기기, 스택 트레이스 등)는 에러가 처음 인스턴스화될 때 채워지지만==, ==아키텍처는 모듈의 경계에서 이 에러를 적절한 정보로 채워진 모듈의 에러 타입으로 변환할 것을 지시한다.== **이제 모듈의 에러 타입이 아닌 상태로 모듈을 벗어나는 모든 에러는 잘못된 형식으로 간주될 수 있으며, 버그가 될 수 있다.** 공개(public) 함수나 메서드와 같은 자기 모듈의 경계에서, 혹은 코드에 유용한 컨텍스트를 추가할 수 있는 경우에만 에러를 이 방식으로 감싸면 된다는 점에 대해서 유의하자. 이로 인해 보통은 코드에서 에러를 감쌀 필요가 없게 된다.

이 입장을 취하면 시스템은 매우 유기적으로 성장할 수 있다. ==전달받은 에러가 올바른 형태라고 확신할 수 있으며, 최종적으로 에러가 모듈 밖으로 나가는 방식을 확정할 수 있다.== ==에러 정확성이 곧 시스템의 새로운 속성이 된다.== 우리는 잘못된 형식의 에러를 명시적으로 처리함으로써 시스템이 최초에 완벽한 상태임이 받아들이고, 이를 기반으로 시간이 지나면서 발생할 수 있는 실수들을 포착해 수정할 수 있는 프레임워크를 보유하게 됐다. 타입이나 사용자에서 보여주는 내용을 바탕으로 잘못된 형식의 에러를 분명하게 기술할 수 있다.


앞서 확립한 프레임워크에 따르며, 모든 에러는 가능한 한 많은 정보와 함께 기록돼야 한다. 그러나 사용자에게 에러를 표시하는 시점에서 버그와 알려진 경계 케이스의 차이가 발생한다.

사용자가 대하는 코드가 올바른 형식의 에러를 받으면, 코드의 모든 단계에서 에러 메시지를 작성하는 데 주의를 기울였다는 사실을 확인할 수 있으며, 사용자가 볼 수도 있도록 간단히 기록하고 출력할 수 있다. 올바른 타입의 에러를 보면서 얻을 수 있는 자신감은 간과할 수 없다.
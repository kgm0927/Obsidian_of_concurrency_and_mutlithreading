
대부분의 경우처럼 오류를 바로잡기보다는 오류를 범하지 않는 것이 최선이다. 7장은 멀티스레드 애플리케이션에서의 여러 흔한 실수와 설계 문제를 살펴보고 일반적인 문제(그리고 흔치 않은 문제)를 방지하는 법을 보여준다.

7장에 다루는 주제는 다음과 같다.

- 데드락과 데이터 경쟁 같은 일반적인 멀티스레딩 문제
- 뮤텍스와 락의 적절한 사용과 함정들
- 정적 초기화를 사용할 때의 잠재적 문제

---
# 올바른 멀티스레딩

이전 장들에서 멀티스레드 코드를 작성할 때 발생할 수 있는 다양한 잠재적 문제를 봤다. 이들 문제는 두 스레드가 동시에 동일한 위치에 쓰기 작업을 할 수 없는 명확한 것에서부터 뮤텍스의 부정확한 사용법 같이 좀 더 미묘한 것까지 걸쳐 있다.

==멀티스레드 코드와 직접적인 관련이 없는 요소와 관련된 많은 문제도 존재한다.== 그럼에도 이런 문제들은 임의의 크래시나 그 밖의 어려운 문제를 유발시킬 수 있다. 한 예로 **변수의 정적 초기화**가 있다. 다음 절에서 이런 문제를 항상 처리해야 하는 것을 방지할 수 있는 방법과 더불어 이들 문제의 많은 문제를 많은 부분을 살펴볼 것이다.


---
# 잘못된 기대-데드락

데드락은 그 이름으로 이미 꽤나 간결하게 설명이 된다. ==이것은 둘 또는 그 이상의 스레드가 다른 스레드를 소유하고 있는 한 자원에 대한 접근 획득을 시도할 때== 그리고 ==이때 락을 소유한 바로 그 스레드는 동시에 자신이 소유하고 있는 자원에 대한 접근 획득을 대기 중인 상황에서 발생==한다.

예를 들면 다음과 같다.

1. 스레드 1은 자원 A에 대한 접근을 얻는다.
2. 스레드 1과 2둘 모두는 자원 B에 대한 접근을 얻고자 한다.
3. 스레드 2가 승리하여 이제 B를 소유하고 있다. 스레드 1은 여전히 B를 대기하고 있다. 
4. 스레드 2는 이제 A를 사용하기를 원하여 접근을 대기한다.
5. 두 스레드 1과 2는 자원에 대해 영원히 대기한다.

이 상황에서 각각의 스레드는 다른 스레드가 필요로 하는 자원을 소유하고 있어서 스레드는 어느 시점에서 각각의 자원에 대한 접근을 획득할 수 있을 것이라고 가정한다(반대의 경우도 성립한다).

이 데드락 과정을 시각화하면 다음과 같다.

![[기본 폴더 - 1 3.jpg]]

이 사실로부터 데드락을 방지하는 두 가지 기본 규칙이 존재한다.

- 가능하다면 두 개 이상의 락을 소유하지 않도록 한다.
- 가능하면 빨리 소유한 락을 해제한다.

4장. '[[스레드 동기화와 통신]]'에서 [[스레드 동기화와 통신#^f070f3|디스패처 데모 코드]]를 살펴볼 때 이에 대한 실제 예제를 봤다. 다음의 코드에서 두 데이터 구조체에 대한 안전한 접근을 위해 두 개의 뮤텍스가 관여한다.


``` c++
void Dispatcher::addRequest(AbstractRequest* request){

    workersMutex.lock();

    if(!workers.empty()){
        Worker* worker=workers.front();
        worker->setRequest(request);
        condition_variable* cv;
        worker->getCondition(cv);
        cv->notify_one();
        workers.pop();
        workersMutex.unlock();

    }else

    {
        workersMutex.unlock();
        requestsMutex.lock();
        requests.push(request);
        requestsMutex.unlock();
    }

}
```

여기서 뮤텍스는 변수 WorkersMutex와 requestMutex다. 다른 뮤텍스에 대한 접근 시도를 하기 전에 어떤 시점에서도 나머지 한 뮤텍스를 소유하고 있지 않음을 명확히 볼 수 있다. 이 메소드의 시작 부분에서 명시적으로 workersMutex를 락하여 workers 데이터 구조체가 비어 있는지 여부를 안전하게 검사할 수 있다.

이것이 비어있지 않다면 새로운 요청을 작업자에게 전달한다. 이제 workers 데이터 구조체에 대한 작업을 마쳤으므로 해당 뮤텍스를 해제한다. 이 시점에서는 소유하고 있는 뮤텍스가 없다. 여기서는 단 하나의 뮤텍스만 사용하기 때문에 복잡한 상황이 전혀 없다.

==흥미로운 부분은 대기 중인 작업자가 존재하지 않는 경우로 두 번째 뮤텍스의 획득이 필요한 else 문에 있다.== 이 영역으로 진입할 때 하나의 뮤텍스를 소유한 상태다. 단지 requestMutex 획득을 시도해 이것이 동작할 수 있다고 가정할 수 있겠지만 이 단순한 이유로 인해 데드락에 이를 수 있다.

``` c++
bool Dispatcher::addWorker(Worker* worker){

    bool wait=true;
    requestsMutex.lock();

    if(!requests.empty()){
        AbstractRequest* request=requests.front();
        worker->setRequest(request);
        requests.pop();
        wait=false;
        requestsMutex.unlock();
    }else{
        requestsMutex.unlock();
        workersMutex.lock();
        workers.push(worker);
        workersMutex.unlock();
    }
    return wait;
}

```

살펴본 이전 함수와 함께 이 함수 역시 동일한 두 뮤텍스를 사용한다. 더군다나 이 함수는 별도의 스레드에서 동작한다. 결과적으로 이전에 살펴본 첫 번째 함수가 requestsMutex 획득을 시도하면서 workerMutex를 소유하고, 이 두 번째 함수가 workerMutex획득하기 시도하면서 그와 동시에 requestsMutex를 소유한 상태라면 데드락이 발생한다.


하지만 여기서 보듯이 이 함수에서는 두 가지 규칙 모두 성공적으로 규현돼 있다. 한 순간에 두 개 이상의 락을 소유하지 않으며 가능한 빨리  소유한 락을 해제한다. 이것은 이 들 함수의 else 부분에 모두 볼 수 있다. else 문에 진입하면 먼저 더 이상 필요 없는 락을 해제한다.

두 경우 모두 workers 또는 requests 데이터 구조체를 개별적으로 더 이상 검사하지 않아도 된다. 다른 작업을 하기 전에 관련 락을 해제할 수 있다. 이를 도식화하면 다음과 같다.

![[기본 폴더 - 2 2.jpg]]

물론 둘 또는 그 이상의 데이터 구조체나 변수에 포함된 데이터(다른 스레드에 의해 동시에 사용되는)를 사용할 필요가 있을 수도 있다. 이런 코드에서 데드락의 가능성이 없도록 보장하는 것은 어려울 수 있다.

여기서는 임시 변수나 그 유사한 것을 사용하는 것을 고려해볼 수 있다. ==뮤텍스를 락하고 관련 데이터를 복사하고 즉시 락을 해제하면 이 뮤텍스와 관련된 데드락 가능성은 없다.== 그 결과를 다시 데이터 구조체에 기록해야 하더라도 이것은 별도의 동작으로 가능하다.

이런 사실은 데드락 방지에 대한 추가적인 두 가지 이상의 규칙을 추가한다.


- 어느 한 순간에 두 개 이상의 락을 소유하지 않는다.
- 가급적 빨리 소유한 락을 해제한다.
- 반드시 필요하지 않다면 락을 더 이상 소유하지 않는다.
- 복수의 락을 소유할 때, 그 순서에 유념하자.


---
# 부주의-데이터 경쟁


==경쟁 상태(race condition)라고도 불리는 데이터 경쟁(data race)은 둘 또는 그 이상의 스레드가 동시에 동일한 공유 메모리에 쓰기를 시도할 때 발생한다.== 결과적으로 각 스레드에 의해 실행되는 명령 순서 동안과 그 종료 시점의 공유 메모리의 상태는 정의에 의하면 비결정(deterministic) 상태에 놓이게 된다.

6장 '[[멀티스레드 코드의 디버깅]]'에서 살펴본 것처럼 데이터 경쟁은 멀티스레드 애플리케이션 디버깅에 사용되는 툴에 의해 흔히 보고된다. 다음과 같다.

![[기본 폴더 - 1 4.jpg]]
![[기본 폴더 - 2 3.jpg]] 
이 경고를 생성시킨 코드는 다음과 같다.

``` c++

bool Dispatcher::stop(){

    for (int i = 0; i < allWorkers.size(); i++)
    {
      allWorkers[i]->stop();
    }

    cout<<"Stopped workers.\n";

    for (int ii = 0; ii < threads.size(); ii++)
    {
        threads[ii]->join();
        cout<<"Joined threads.\n";
    }

    return true;

}
```

Worker 인스턴스에서 이 코드를 고려해보자.

``` c++
void stop(){running=false;}
```

또한 다음의 코드도 고려하자.

``` c++
void Worker::run(){

    while(running){
        if(ready){
            ready=false;
            request->process();
            request->finish();
        }

  

        if(Dispatcher::addWorker(this)){

            // Use the ready loop to deal with spurious wake-ups.

            while(!ready&& running){

                if(cv.wait_for(ulock,chrono::seconds(1))==cv_status::timeout){
                    // We timed out, but we keep waiting unless
                    // the worker is
                    // stopped by the dispatcher.

                }
            }
       }
    }
}
```

여기서 **running**은 false로 설정되고 있는 불리언 변수(하나의 스레드가 여기에 쓰기 작업 중이다)로 작업자 스레드에게 그 대기 루프를 종료할 것을 시그널한다. 이 루프에는 불리언 변수를 읽는 동작이 상이한 스레드(주 스레드와 작업자 스레드)에서 이루어진다.

![[기본 폴더 - 3 4.jpg]]

이 특정 예제의 경고는 동시에 씌어지고 읽히는 한 불리언 변수로 인한 것이다. 당연하게 이 특정 상황이 안전한 이유는 8장 '[[원자적 동작-하드웨어와 작업하기]]'에서 자세히 설명할 원자적 동작과 관련이 있다.

이런 동작조차도 잠재적으로 위험한 이유는 변수가 갱신되는 과정 동안에 읽기 동작이 발생할 수 있기 때문이다. 예를 들어 32-비트 정수의 경우, 하드웨어 아키텍처에 따라 이런 변수 갱신은 하나 또는 여러 동작에 의해 이뤄질 수 있다. 후자의 경우 읽기 동작은 작은 예측이 어려운 결과를 지닌 변경 중 값을 읽을 수도 있다.

![[기본 폴더 - 4 4.jpg]]

여러 스레드가 cout을 사용해 표준 출력 장치에 쓰기를 할 대 좀 더 이상한 상황이 연출될 수 있다. ==이 스트림은 스레드 안전하지 않기 때문에 스레드 중 하나가 기회가 있을 때마다 쓰게 됨으로 출력 스트림은 입력 스트림의 비트와 조각 부분을 갖게 될 것이다.==


![[기본 폴더 - 5 4.jpg]]


따라서 데이터 경쟁을 방지하기 위한 기본 규칙은 다음과 같다.

- 락이 안됐거나, 비자원적 공유 자원에 쓰기를 하지 않는다.
- 락이 안됐거나, 비자원적 공유 자원으로부터 읽기를 하지 않는다.

이것은 기본적으로 모든 쓰기나 읽기 동작은 스레드 안전해야 한다는 것을 의미한다. ==한 스레드가 공유 메모리에 쓰기를 한다면 그 외의 나머지 스레드는 동시에 이 공유 메모리에 쓸 수 없다.== 마찬가지로 공유 자원을 읽을 때 다른 스레드 역시 해당 공유 자원을 읽는 것만은 보장해야 한다.


이런 수준의 상호 배제는 6장에서 살펴본 정교함이 더해진 읽기-쓰기 락을 가진 뮤텍스로 자연스럽게 이어진다. 이들을 이용하면 완전히 상호 배타적인 이벤트로서 쓰기 작업을 하면서도 여러 리더가 동시에 수행할 수 있다. 

물론 다음 절에서 살펴보겠지만 뮤텍스에도 문제가 존재한다.


---
# 만능이 아닌 뮤텍스

뮤텍스는 실질적으로 모든 행태의 상호 배제에 대한 기본을 형성한다. 그 핵심은 매우 간단하다. 즉, ==실질적으로 스레드만인 뮤텍스를 소유할 수 있고 그 외의 모든 스레드는 뮤텍스에 대한 락을 획득할 때까지 큐에서 대기한다.==


![[기본 폴더 - 6 2.jpg]]


==물론 현실은 하드웨어에 의해 부가된 실질적인 제약으로 인해 그렇게 깔끔한 것은 아니다. 한 가지 명확한 제약은 동기화 기본 요소가 자유롭지 못하다는 사실이다.== 이들 기본 요소는 하드웨어에 구현됐을지라도 동작하도록 하려면 여러 호출을 필요로 한다.


하드웨어에서 뮤텍스를 구현하는 가장 일반적은 두 가지 방법은 TAS(test-and_set, 검사 후 설정)나 CAS(compare-and-swap,비교 후 교환)의 CPU 기능 중 하나를 사용하는 것이다.

TAS는 일반적으로 인터럽트되지 않는 독자적으로 실행하는 두 개의 어셈블리 수준의 명령어로 구현된다. 첫 번째 명령어는 특정 메모리 영역이 1 또는 0으로 설정돼 있는지 검사한다. 두 번째 명령어는 해당 값이 0(false)일 때만 실행한다. 이것은 뮤텍스가 아직 락되지 않았음을 의미한다. 따라서 두 번째 명령어는 해당 메모리 영역을 1로 설정한다.

이것에 대한 의사  코드는 다음과 같다.

``` c++
bool TAS(bool lock){
if(lock){
return true;
}
else{
lock=true;
return false;
}
}
```

메모리 위치와 주어진 값에 대해 비교 연산을 수행하고 이들 두 값이 일치한다면 해당 메모리 위치의 내용을 교환하는 CAS는 좀 더 덜 사용되는 변형이다.

``` c++
bool CAS(int*p,int old,int new){
if(*p!=old){
return false;
}
*p=new;
return true;
}
```

두 경우 모두, 양수값이 반환될 때까지 계속해서 해당 함수를 다음과 같이 반복 실행해야 한다.

``` c++

volatile bool lock=false;
void critical(){
while(TAS(&lock)==false);
// Critical section
lock=0;
}
```

이 코드는 메모리 영역을 계속 폴링하는 데 사용되는 while 루프다(발생할 수 있는 컴파일러 최적화 문제를 발생하기 위해 volatile로 선언된). 일반적으로 이를 위해 폴링되는 속도를 느리게 감소하는 알고리즘이 사용된다. 이것은 프로세서와 메모리 시스템의 압박을 줄여준다.

==이것은 뮤텍스의 사용은 비용이 따르지만 뮤텍스 락을 대기하는 각 스레드가 자원을 적극적으로 사용한다는 것을 분명히 한다.== 결과적으로 일반적인 규칙은 다음과 같다.

- 스레드가 뮤텍스나 이와 유사한 락을 기다리는 경우 가급적 짧게 대기하도록 한다.
- 좀 더 긴 대기 기간인 경우에는 조건 변수나 타이머를 사용한다.

---
# 훌륭한 뮤텍스인 락

뮤텍스에 관한 절에서 살펴봤듯이 뮤텍스 사용시 유념할 몇몇 문제들이 존재한다. 이들 문제의 일부분이 이들 API에 의해 다소 완화될지라도 당연하게 뮤텍스에 기반한 메커니즘과 락을 사용할 때도 이런 상황은 적용된다.

처음에 멀티스레딩 API를 사용할 대 혼란스러울 수 있는 사항 중 하나는 상이한 동기화 유형 간의 실질적 차이점이다. 7장 초반에서 다루었듯이 뮤텍스는 실제로 모든 동기화 메커니즘을 다룬다. 단지 이들 메커니즘은 뮤텍스를 사용해 제공된 기능을 구현하는 방식만 다를 뿐이다.

여기서 중요한 점은 이들은 별개의 동기화 메커니즘이 아니라 기본 뮤텍스 유형의 특화된 메커니즘이라는 것이다. 일반 뮤텍스나 읽기-쓰기 락, 세마포어, 재진입이 가능한(재귀적) 뮤텍스나 락 같은 다소 생소한 것 중에서 어느 것을 사용하는가는 해결해야 할 특정 문제에 전적으로 달려있다.

4장 '스레드 동기화와 통신'에서 처음 소개한 [[스레드 동기화와 통신#스케줄러|스케줄러]]의 경우, 큐잉된 작업자 스레드와 요청을 가지는 데이터 구조체를 보호하기 위해 일반 뮤텍스를 사용했다. ==이들 두 데이터 구조체에 대한 접근은 읽기 동작과 구조체에 대한 조작이 수반될 가능성이 크기 때문에 읽기-쓰기 락을 사용할 수는 없었다.== 마찬가지로 재귀적 락은 일반 뮤텍스에 대해 그 목적을 충족시킬 수 없을 것이다.

따라서 각 동기화 문제에 있어서 다음과 같은 질문을 해야 한다.

- 요구 사항이 무엇인가?
- 해당 요구 사항이 최적의 동기화 메커니즘은 무엇인가?


따라서 복잡한 유형을 선택하면 매력적이겠지만 일반적으로 모든 요구 조건을 만족시키는 좀 더 단순한 유형을 고수하는 것이 최선이다. 이렇게 하면 자신의 구현을 디버깅할 때 환상적인 구현에 비해 귀중한 시간을 절약할 수 있다.


---
# 스레드 대 퓨처

최근 스레드의 사용에 반해 대신 프라미스 같은 다른 비동기 처리 메커니즘의 사용을 권장하는 것이 인기를 얻고 있다. 이것에 대한 이면의 이유는 스레드와 동기화의 사용이 복잡하고 실수를 저지르기 쉽다는 데 있다. ==태스크를 병렬로 실행하고 그 결과가 얻어지는 방식에는 관심을 두고 싶지 않을 때가 종종 있다.==
짧게 실행하는 간단한 태스크의 경우 이것은 분명히 일리가 있어 보인다. 스레드 기반의 구현에서 주요 장점은 개발자는 자신의 동작을 전적으로 커스텀화할 수 있다는 것이다. 프라미스를 이용해 실행할 작업을 보내고 마지막에 퓨처 인스턴스로부터 결과를 구한다.
이것은 단순한 태스크에는 편리하지만 확실히 많은 상황을 다루지 못한다.


여기서 최선의 접근법은 먼저 스레드와 동기화 메커니즘, 이들의 제약을 숙지하는 것이다. 그 이후에 프라미스나 packaged_task, 완전한 스레드를 사용할 지 여부를 고려하는 것이 실제로 의미가 잇다.

==이들 선호 대상과 더불어 또 다른 주요 고려 사항은 **퓨처 기반의 API**는 주로 템플릿 기반에 근거한다는 것이다.== 이 사실은 발생할 수 있는 문제를 디버깅하고 해결하는 것이 좀 더 직관적이고 저수준의 API를 사용할 때보다 훨씬 어려울 수 있음을 의미한다.

---

# 초기화의 정적 순서

정적 변수는 단 한 번 선언되는 변수로 특정 클래스 인스턴스 간에 공유되기도 하지만 기본적으로 전역 영역에 존재한다. 완전히 정적인 클래스를 가지는 것 또한 가능하다.

``` c++

class Foo{
static std::map<int, std::string> strings;
static std::string oneString;

public:
static void init(int a,std::string b,std::string c){
strings.insert(std::pair<int,std::string>(a,b));
oneString=c;
}

std::map<int,std::string> Foo::strings;
std::string Foo::oneString;

}


```

여기서 보다시피 정적 함수와 정적 변수는 매우 간단하지만 강력한 개념이다. 그 핵심에 있어서 이것은 사실이지만 정적 변수와 클래스의 초기화와 관련해 방심할 수 있는 중요한 문제가 존재한다. 이 문제는 초기화 순서에서 발생한다.

다음과 같이 다른 클래스의 정적 초기화에서 이전 클래스(Foo 클래스)를 사용한다면 어떤 일이 발생할 지 고려해보자.

``` c++
class Bar{
static std::string name;
static std::string initName();
public:
	void init();
};

// Static initializations.
std::string Bar::name=Bar::initName();

std::string Bar::initName(){
Foo::init(1,"A","B")
return "Bar";
}
```

이것이 잘 동작하는 것처럼 보일지는 모르겠지만 정수를 키로 하여 클래스의 map 구조체에 첫 번째 문자열을 추가하면 이 코드가 크래시될 가능성이 매우 높다. 그 이유는 간단하다. Foo::init()을 호출할 때 이 시점에서 Foo::string이 초기화된다는 보장이 없기 때문이다. 따라서 초기화되지 않은 map 구초체를 사용하려는 시도는 예외로 이어진다.

즉, 정적 변수의 초기화 순서는 기본저긍로 임의적이며 따라서 이를 고려하지 않으면 비결정적 동작으로 이어진다.

이 문제에 대한 해결책은 매우 간단하다. 기본적으로 목표는 이전 예제에서와 같이 암시적으로 초기화를 하는 대신 좀더 복잡한 정적 변수의 초기화는 명시적으로 하는 것이다. Foo 클래스는 다음과 같이 변경한다.

``` c++
class Foo{
static std::map<int,std::string>& strings();
static std::string oneString;
public:
	static void init(int a,std::string b, std::string c){
		static std::map<int, std::string> stringsStatic=Foo::strings();
		stringsStatic.insert(std::pair<int,std::string>(a,b));
		oneString=c;
	}
};

std::string Foo::oneString;

std::map<int, std::string>& Foo::strings(){
static std::map<int,std::string>* stringStatic=new std::map<int, std::string>();

return *stringsStatic;
}

```


위에서 살펴보면 더 이상 정적 map을 직접적으로 정의하지 않음을 알 수 있다. 대신, 같은 이름의 전용 함수가 존재한다. 이 함수의 구현은 이 예제 코드의 마지막 부분에 보인다. 이 함수는 친숙한 map 정의를 가진 map 구조체에 대한 정적 포인터를 가진다.

이 함수가 호출될 대 아직 인스턴스가 존재하지 않았다면(정적 변수이기 때문에) 새로운 map이 생성된다. ==수정된 init() 함수에서는 strings() 함수를 호출해 이 인스턴스에 대한 참조를 구한다.== 이것은 명시적 초기화의 일부분이다. ==이 함수를 호출하는 것은 map 구조체가 사용되기 전에 초기화된다는 것을 항상 보장하므로 앞서 언급한 문제는 이제 해결된다.==

여기에는 또한 간단한 최적화 부분도 보인다. 생성한 stringsStatic 변수 또한 정적인데 이것은 strings() 함수를 단 한 번만 호출할 것임을 의미한다. 이로써 반복적인 함수 호출이 불필요하고 이전의 단순하지만 불완전한 구현에서 가질 수 있었던 속도도 다시 복구할 수 있게 됐다.

따라서 정적 변수 초기화에서 필수적 규칙은 단순하지 않은 정적 변수의 경우 항상 명시적 초기화를 사용해야 한다는 것이다.





8장에서는 C++11dp 소개된 `<atomics>` 헤더와 더불어 원자적 동작의 이점을 이용하기 위해 하부의 하드웨어를 이용하는 방법에 대해 알아본다.

이상적으로 처음에 코드가 제대로 작동하고 애플리케이션이 크래시(crash)되거나 데이터가 손상되거나, 다른 문제가 유발될 수 있는 숨겨진 버그를 가지지 않아야 한다. 물론 현실에서 이것은 불가능한 일이다. 그래서 멀티스레드 애플리케이션을 쉽게 검사하고 디버깅할 수 있는 툴이 개발됐다.

6장에서는 Valgrind 슈트의 일부인 몇몇 툴(특별히 Helgrind와 DRD)과 더불어 일반적인 디버거를 포함한 여러 툴을 살펴볼 것이다. 멀티스레드 애플리케이션 설계에서 핫스팟(hotspots)과 잠재적 문제를 찾기 위해 멀티스레트 애플리케이션 프로파일링을 또한 살펴볼 것이다.

6장에서 다루는 주제는 다음과 같다.

- Valgrind 슈트 툴 소개
- Helgrind와 DRD 툴의 사용
- Helgrind와 DRD의 분석 결과 해석하기
- 애플리케이션의 프로파일링과 그 결과 분석하기

---
# 언제 디버깅을 해야 하는가

이상적인 것은 특정 목표에 이를 때마다 단일 모듈이든, 여러 모듈이든 또는 전체 애플리케이션이든 간에 자신의 코드를 테스트하고 검증하는 것이다. 가정한 것이 최종적 기능과 일치하는지 확인하는 것이 중요하다.

특히 멀티스레드 코드인 경우 특정 오류 상태가 매번 애플리케이션을 실행할 때마다 발생하지 않는다는 점에서 우연적인 요소가 크게 작용된다. ==부적절하게 구현된 멀티스레드의 애플리케이션의 증상은 결과 아무 때나 비정상적으로 크래시되는 현상으로 이어질 수 있다.==


첫 조짐으로 애플리케이션이 크래시될 대 무엇인가 올바르지 않다는 첫 증상이 나타나고 이에 대한 덤프를 보게 될 것이다. **덤프**는 애플리케이션이 크래시될 때 스택을 포함한 메모리 내용을 가지는 파일이다.

==이 핵심 덤프는 실행 프로세스에 디버거를 구동함으로서 거의 동일한 방식으로 사용될 수 있다. 이것은 스레드 내에서 크래시가 발생한 코드의 위치를 조사하는데 특히 유용하다.== 이 방식으로 메모리 내용 또한 살펴볼 수 있다.

멀티스레딩 문제를 다루는 가장 좋은 지표 중 하나는 ==애플리케이션이 동일한 위치(상이한 스택 추적)에서 크래시되지 않거나 전역 데이터 구조체를 조작하는 것과 같이 **상호 배제** 동작을 수행하는 지점에서 항상 크래시되는 상황이다.==

시작에 앞서 Valgrind 슈트 툴을 살펴보기 전에 진단과 디버깅을 위한 디버거 사용법을 좀 더 자세히 살펴볼 것이다.

---
# 단순한 디버거

개발자가 가지는 여러 의문점 가운데 **"애플리케이션이 왜 크래시될까?"** 라는 것이 아마도 가장 중요할 것이다. 이 의문점은 디버거를 통해 가장 손쉽게 답변할 수 있다. 프로세스를 라이브 디버깅하든지 또는 크래시된 프로세스의 핵심 덤프를 분석하든지 간에 디버거는 스택 추적(stack trace)으로도 불리는 **백 트레이스**(back trace)를 생성할 수 있다(희망 사항이지만). 이 추적 정보에는 개발자가 스택에서 찾고자 하는 함수에 대해 애플리케이션이 시작된 이후로 호출된 모든 함수의 시간순 목록이 포함되 있다(스택이 동작하는 세부적 방법은 2장 [[프로세서와 OS에서의 멀티스레딩 구현]]을 참고하자).

따라서 이 백트레이스의 마지막 몇몇 항목은 코드의 어느 부분에서 잘못했는지 보여준다. 디버그 정보가 바이너리에 포함돼 컴파일됐거나 또는 디버거가 이 정보를 제공받으면, 변수의 이름과 더불어 해당 라인의 코드를 볼 수 있다..

상황이 더욱 좋은 것은 스택 프레임을 살펴보고 있기 때문에, 스택 프레임 내의 변수를 조사해 볼 수도 있다. 이것은 인자가 지역 변수와 그 값이 함께 함수에 전달됐음을 의미한다.

디버그 정보(심볼)을 이용하려면 적절한 컴파일러 플래그를 설정한 채로 소스 코드를 컴파일해야 한다. GCC의 경우 디버그의 정보의 레벨과 유형에 대한 한 가지 안을 선택할 수 있다. 가장 흔하게 디버그 레벨을 저장하는 정수가 붙은 -g 플래그를 다음과 같이 사용한다.

- -g0: 디버그 정보를 만들지 않는다.(-g를 무효화한다.)
- -g1: 함수 설명과 외부 변수에 대한 최소의 정보
- -g3: 매크로 정의를 포함한 모든 정보

==이 플래그는 GCC로 하여금 OS에 대한 네이티브 형식으로 디버그 정보를 생성하도록 한다.== 물론 다른 플래그를 사용해 특수한 형식으로 디버그 정보를 생성할 수도 있다. 하지만 GCC 디버거(GDB)와 Valgrind인 경우에는 이렇게 할 필요가 없다.


GDB와 Valgrind는 이 디버그 정보를 사용한다. 디버그 정보를 이용할 수 없더라도 기술적으로 이들툴을 사용하는 것이 가능하지만 불가피한 경우에만 이렇게 한다.


### GDB

C와 C++를 기반으로 하는 코드에서 가장 흔히 사용하는 디버거 중 하나는 GNU 디버거(간단히 GDB)다. 이 디버거가 광범위하게 사용되고 무료로 할 수 있기 때문에 다음 예제에서 이를 사용한다. 1986년에 처음 작성된 이 디버거는 광범위한 프로그래밍 언어에서 사용되고 개인적인 용도나 전문적인 용도롤 가장 흔히 사용되고 있다.


GDB 디버거의 가장 기본적인 인터페이스는 명령행 셸이지만 Qt Creator와 Dev-C++,Code::Blocks와 같은 여러 IDE를 포함하는 그래픽 프론트엔드(frontend)방식으로 사용할 수도 있다. 이들 프론트엔드와 IDE는 브레이크포인트와 변수 보기 설정, 그 밖의 일반적인 동작을 직관적으로 좀 더 쉽게 조작할 수 있다. 그렇다고 하더라도 반드시 이들을 사용해야 하는 것은 아니다.

리눅스와 BSD 보급으로 인해 MSYS2가 장착된 윈도우나 유사한 유닉스 환경처럼 패키지를 통해 gdb를 통해 쉽게 설치할 수 있다. OS X/MacOS의 경우, HomeBrew 같은 서드파티 패키지 관리자를 이용해 gdb를 설치해야 한다.

gdb는 일반적으로 MacOS에서는 코드 서명이 돼 있지 않아 일반 동작에 필요한 시스템 레벨의 접근을 할 수가 없다. 이런 경우 gdb를 루트(권장하지 않음)로 실행하거나 독자의 MacOS 버전에 맞는 지침서를 따라야 한다.



### 멀티스레드 코드의 디버깅

앞서 언급했듯이 디버거 내에서 애플리케이션을 시작하든가(즉, 실행 중인 프로세스에 연결해) 또는 핵심 덤프 파일을 로드하는 두 가지 방법을 사용해 디버거를 사용할 수 있다. 디버깅 세션에서 실행 중인 프로세스를 인터럽트할 수 있거나(SIGINT 시그널을 보내는 ctrl+c로)또는 로드된 핵심 덤프 파일에 대한 디버그 심볼을 로드할 수 있다. 이 작업 이후 해당 프레임 내에 활성 스레드를 조사할 수 있다.

[그림]

이 코드에서 SIGINT 시그널을 애플리케이션(OS X에서 실행하는 Qt 기반 애플리케이션)에==보낸 이후에 스레드 번호와 ID, 현재 스레드가 실행하는 함수와 더불어 현재 이 시점에 존재하는 모든 스레드의 목록을 요청하는 방법을 볼 수 있다.== ==이것은 또한 이와 같은 그래픽 사용자 인터페이스 애플리케이션에서의 흔한 경우처럼 후자의 정보를 기반으로 해 어떤 스레드가 대기할 가능성이 있는지 명확히 보여준다.== 애플리케이션에서 그 번호(스레드 1) 앞에 별표(`*`)로 표시된 현재 활성 상태인 스레드를 볼 수 있다.

`thread <ID>` 명령을 사용해 스레드 간에 전환할 수 있고 스레드의 스택 프레임을 위, 아래로 이동할 수 있다. 이를 통해 개별 스레드의 모든 면면을 조사할 수 있다.

==전체 디버그 정보를 이용할 수 있다면 일반적으로 스레드가 실행 중인 코드의 정확한 라인을 볼 수도 있다.== 이것은 애플리케이션 개발 단계에서 가급적 많은 디버그 정보를 가질수록 디버깅이 쉬워진다는 의미다.


### 브레이크포인트

4장 '스레드 동기화와 통신'에서 살펴본 디스패처 코드의 경우, 브레이크포인트를 설정해 활성 스레드를 조사할 수 있다.

``` shell
PS C:\C-language\Mutlithreading_CPP\Chapter04> gdb dispatcher_demo.exe
GNU gdb (GDB) 8.1
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-w64-mingw32".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
---Type <return> to continue, or q <return> to quit---
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from dispatcher_demo.exe...done.
(gdb) break main.cpp:47
Breakpoint 1 at 0x401d04: file main.cpp, line 47.
(gdb) run
Starting program: C:\C-language\Mutlithreading_CPP\Chapter04\dispatcher_demo.exe
[New Thread 14256.0x35f4]
[New Thread 14256.0x4818]
[New Thread 14256.0x35c8]
[New Thread 14256.0x1204]
[New Thread 14256.0x10f0]
[New Thread 14256.0x35b4]
[New Thread 14256.0x4bc0]
[New Thread 14256.0x4ac0]
[New Thread 14256.0xf78]
[New Thread 14256.0x2138]
[New Thread 14256.0x4ba0]
[New Thread 14256.0x2b1c]
[New Thread 14256.0x2720]
[New Thread 14256.0xff0]
Initialized.
```

이 명령해 출력에서 볼 수 있듯이 인자로 디버깅할 애플리케이션의 이름을 사용해 GDB를 시작한다. 여기서는 윈도우에서 Bash 셸을 사용한다. 그러고 나서 gdb 명령해 입력에서 (gdb) 바로 뒤에 중단하기를 원하는 소스 파일의 파일 이름과 줄을 명시해 브레이크 포인트를 설정할 수 있다. 요청이 디스패처로 전송되는 루프 다음에 첫 번째 줄을 선택하고서 애플리케이션을 실행한다. ==이제 GDB에 의해 보고가 이루어짐에 따라, 디스패처에 의해 생성되는 새로운 스레드 목록이 그 뒤를 잇는다.==

이제 브레이크포인트에 도달할 때까지 대기한다.

``` shell
(gdb) info threads
  Id   Target Id         Frame
* 1    Thread 14256.0x35f4 main () at main.cpp:47
  2    Thread 14256.0x4818 0x00007fff12953bf4 in ntdll!ZwWaitForWorkViaWorkerFactory () from C:\WINDOWS\SYSTEM32\ntdll.dll
  3    Thread 14256.0x35c8 0x00007fff12953bf4 in ntdll!ZwWaitForWorkViaWorkerFactory () from C:\WINDOWS\SYSTEM32\ntdll.dll
  4    Thread 14256.0x1204 0x00007fff12953bf4 in ntdll!ZwWaitForWorkViaWorkerFactory () from C:\WINDOWS\SYSTEM32\ntdll.dll
  5    Thread 14256.0x10f0 0x00007fff12950024 in ntdll!ZwWaitForSingleObject () from C:\WINDOWS\SYSTEM32\ntdll.dll
  6    Thread 14256.0x35b4 0x00007fff12950024 in ntdll!ZwWaitForSingleObject () from C:\WINDOWS\SYSTEM32\ntdll.dll
  7    Thread 14256.0x4bc0 0x00007fff12950024 in ntdll!ZwWaitForSingleObject () from C:\WINDOWS\SYSTEM32\ntdll.dll
  8    Thread 14256.0x4ac0 0x00007fff12950024 in ntdll!ZwWaitForSingleObject () from C:\WINDOWS\SYSTEM32\ntdll.dll
  9    Thread 14256.0xf78 0x00007fff129500a4 in ntdll!ZwWriteFile () from C:\WINDOWS\SYSTEM32\ntdll.dll
  10   Thread 14256.0x2138 0x00007fff12950024 in ntdll!ZwWaitForSingleObject () from C:\WINDOWS\SYSTEM32\ntdll.dll
(gdb) bt
#0  main () at main.cpp:47
```

브레이크포인트에 도달하면 info threads 명령을 통해 활성 스레드를 나열한다. 스레드 `ntdll!ZwWaitForWorkViaWorkerFactory ()` 내에서 대기하고 있는 조건 변수의 사용을 명확히 볼 수 있다. 3장[[C++ 멀티스레딩 API]]에서 설명했듯이 이것은 자신의 네이티브 멀티스레딩 API를 사용해 조건 변수를 구현한 윈도우의 구현 부분이다.

**백 트레이스**(bt 명령)를 생성해보면 스레드 1(현재 스레드)의 ==현재 스택은 주 메서드만을 위한 단지 하나의 프레임을 갖는데, 이것은 시작 부분인 현재 라인에서 다른 함수를 아직 호출하지 않았기 때문이다.==

### 백 트레이스

앞서 살펴본 GUI 애플리케이션 같이 일반적인 애플리케이션 실행 동안 SIGINT 애플리케이션으로 보내면 다음과 같이 백 트레이스를 만드는 명령을 수반할 수 있다.

``` shell
Thread 15 received signal SIGINT, Interrupt.
[Switching to Thread 7100.0x1a0c]
   from C:\WINDOWS\System32\KernelBase.dll
(gdb) bt
#0  0x00007fff0ff427ce in KERNELBASE!CtrlRoutine ()
   from C:\WINDOWS\System32\KernelBase.dll
#1  0x00007fff1130257d in KERNEL32!BaseThreadInitThunk ()
   from C:\WINDOWS\System32\kernel32.dll
#2  0x00007fff1290af28 in ntdll!RtlUserThreadStart ()
   from C:\WINDOWS\SYSTEM32\ntdll.dll
#3  0x0000000000000000 in ?? ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
(gdb)

```

이 코드에서 그 생성 시점부터 진입점(main)까지의 스레드 ID 1의 실행을 볼 수 있다. ==각 후속하는 함수 호출이 스택에 추가된다. 한 함수가 종료되면 스택에 제거된다.== 이는 장점이자 단점이기도 하다. ==백 트레이스를 깔끔하게 정리하는 반면 마지막 함수 호출 이전에 발생한 이력이 더 이상 스택에 존재하지 않는다는 것을 의미한다.==

핵심 덤프 파일로 백 트레이스를 수행할 때 이런 이력 정보가 없다면 매우 성가시고 크래시의 추정 원인을 줄이는 데 가능성이 희박한 시도에서부터 시작해야 할 수도 있다. 이것은 성공적인 디버깅에서는 어느 정도의 경험이 요구된다는 것을 의미한다.

크래시가 발생된 애플리케이션의 경우 디버거는 크래시를 겪는 스레드에서 시작하도록 한다. 이 스레드가 바로 종종 문제의 코드를 가진 스레드일 수 있지만 실제 문제는 다른 스레드에 의해 실행된 코드나 또는 심지어 변수의 안전하지 않은 사용으로 인한 수 있다. 어떤 스레드가 다른 스레드가 현재 읽고 있는 정보를 변경하고자 한다면 후자의 스레드는 가비지 데이터를 읽어올 수 있다. 이것은 애플리케이션이 크래시될 수도 있고 더욱 나쁜 경우에는 데이터 손상으로 이어질 수도 있다.

최악의 상황은 스택이 와일드 포인터에 의해 덮어쓰기될 수도 있다. 이 경우, 버퍼나 스택 등이 자신의 제한 영역을 벗어나 덮어쓰기될 수 있어 스택의 일부가 새로운 데이터로 채워질 수 있다. 이런 버퍼 오버플로우는 애플리케이션 크래시로 이어지거나 애플리케이션의 (악의적) 취약점으로 작용할 수 있다.

---
# 동적 분석 툴

디버거의 가치는 무시하기 어렵지만 메모리 사용과 누구와 같은 문제를 파악하고 스레딩 문제를 진단하고 예방하기 위해 다른 유형의 툴이 필요한 경우도 있다. 이런 경우가 바로 Valgrind 슈트 같은 동적 분석 툴이 큰 도움이 될 수 있는 분야다. 동적 분석 툴을 구축하기 위한 프레임워크로서 현재 Valgrind 배포판에는 다음과 같은 툴이 존재한다.

- Memcheck
- Helgrind
- DRD

Memcheck는 메모리 오류 탐지기로서 메모리 누수와 불법적인 읽기와 쓰기, 할당, 해제, 그 밖의 메모리 관련 문제를 탐지한다. Helgrind에 비해 더 작은 메모리를 사용하면서 DRD는 분리된 스레드를 지원하고, Helgrind는 락 순서 위반을 탐지한다는 점에서 이 두 툴은 다르다.


### 제약

==동적 분석 툴의 주요 제약은 호스트 운영체제와 긴밀한 통합을 요한다는 것이다.==이것이 바로 Valgrind가 POSIX 스레드에 중점을 두고서 현재 윈도우에서는 작동하지 않는 주된 이유다. Valgrind 웹사이트에는 이 문제에 대해서 다음과 같이 설명하고 있다.

*"윈도우로의 이식은 너무나 많은 변경이 필요하여 별도의 프로젝트로 진행해야 하기 때문에 윈도우는 현재 고려 중에 있지 않다(하지만 Valgrind+Wine은 약간의 노력으로 이식이 가능할 수 있다)". 또한 비 오픈소스 OS는 다루기가 어렵다. OS와 관련 (libc) 소스 코드를 볼 수 있다면 작업이 훨씬 용이할 것이다. 하지만 Valgrind는 Wine과 연계해 사용이 가능하다. 이것은 약간의 노력으로 Valgrind하에서 윈도우 프로그램을 실행할 수 있다는 것을 의미한다.*

기본적으로 이것은 윈도우 애플리케이션은 약간의 어려움을 감수하면 리눅스에서 Valgrind로 디버깅이 가능하다는 것을 의미한다. OS로 윈도우를 이용하는 것은 당분간 기대하기 어려울 듯 하다.

Valgrind는 OS X10.8(마운틴 라이온)부터 OS X/MacOS에서 동작한다. 하지만 최신 버전의 MacOS에 대한 지원은 애플에 의해 가해진 변경으로 인해 다소간 불완전하다. 리눅스 버전의 Valgrind인 경우, 최신 버전의 Valgrind를 사용하는 것이 최선책이다. gdb의 경우, disto 패키지 관리자나 MacOS의 경우 Homebrew처럼 서드 파티의 것을 사용하자.


### 대안

윈도우 그 밖의 다른 플랫폼에서 Valgrind 툴에 대한 대안으로 다음 표에 나열된 툴이 있다.



| 이름                   | 유형               | 플랫폼                 | 라이센스 |
| -------------------- | ---------------- | ------------------- | ---- |
| Dr.Memory            | 메모리 검사기          | 모든 주요 플랫폼           | 오픈소스 |
| gperftools (Google)  | 힙, CPU, 호출 프로파일러 | 리눅스 (x86)           | 오픈소스 |
| Visual Leak Detector | 메모리 검사기          | 윈도우 (비주얼 스튜디오)      | 오픈소스 |
| Intel Inspector      | 메모리와 스레드 디버거     | 윈도우, 리눅스            | 소유권  |
| PurifyPlus           | 메모리, 성능          | 윈도우, 리눅스            | 소유권  |
| Parasoft Insure++    | 메모리 스레드 디버거      | 윈도우, 솔라리스, 리눅스, AIX | 소유   |



### Memcheck


Memcheck는 실행 파일 인자에 다른 툴이 지정되지 않는 경우에 기본 Valgrind 툴이다. Memcheck는 다음과 같은 유형의 문제를 탐지할 수 있는 메모리 오류 탐지기다.

- 할당된 메모리의 **경계를 벗어난 접근**과 **스택 오버플로우**, 이전에 해제된 메모리 블록의 접근
- 초기화되지 않은 변수와 같이 정의되지 않은 값의 사용
- 반복해서 블록을 해제하는 것을 포함해 **힙 메모리의 부적절한 해제**
- 배열 할당자와 해제자(new[] 와 delete[])를 포함해 C와 C++ 형식의 메모리 할당에 불일치되는 사용
- mempy 같은 함수에서 소스와 대상 포인터의 겹침
- 크기 인자로 유효하지 않은 값(예를 들어 음수)을 **malloc이나 그 유사한 함수로 전달**
- 메모리 누수, 즉, 자신들에 대한 유효한 참조가 없는 입 블록

디버거나 간단한 태스크 관리자를 사용해 앞서 소개한 목록의 문제를 탐지하기란 실질적으로 불가능하다. Memcheck의 가치는 데이터 손상이나 원인이 명확하지 않은 크래시로 이어질 수 있는 문제를 개발 초기에 탐지하고 수정할 수 있다는 것이다.


### 기본 사용

Memcheck의 사용은 꽤 용이하다. 4장 '[[스레드 동기화와 통신]]'에서 소개한 데모 애플리케이션을 사용한다면 다음과 같이 실행하는 것은 익히 알 것이다.

``` shell
$ ./dispatcher_demo
```

로그 파일에 출력 결과를 로그로 남기면서 기본 Memcheck 툴 기능으로 Valgrind을 실행하기 위해 다음과 같이 시작한다.

(Valgrind는 리눅스 환경에서 실행이 가능하다. 따라서 여기서는 기록만 해 두겠다.)


``` shell
PS C:\C-language\Mutlithreading_CPP\Chapter04> valgrind --log-file=dispatcher.log --read-var-info=yes --leak-check=full ./dispatcher_demo
```

이 명령은 바이너리 내의 가용한 디버그 정보를 사용해 Memcheck의 출력을 dispatcher.log로 명명된 파일에 로그로 남기며, 메모리 누수가 발생한 지점에 대한 세부적 보고를 포함해 메모리 누수에 대한 완전한 검사가 이뤄지게 한다. 또한 다양한 정보를 읽어 (--read-var-info=yes), 메모리 누수가 발생한 지점에 대한 좀 더 세부적 정보를 구한다.

==매우 단순한 애플리케이션이 아니라면 Valgrind로부터의 출력물이 터미널 버퍼에 적합하지 않을 만큼 너무나 방대해 파일에 로그를 남길 수 없다.== 출력을 파일로 남겨두면 나중에 참고로 사용할 수 있고 또한 터미널이 통상적으로 제공하는 툴보다 더 고급 툴을 사용해 파일을 조사할 수도 있다.


이 실행 이후에 다음과 같은 로그 파일의 내용을 살펴볼 수 있다.

[그림]


여기서 총 3건의 메모리 누수를 볼 수 있다. 이들 중 두 건은 dispatcher 클래스 메모리 할당 부분인 라인 38과 40에서 발생한 것이다.

``` c++
w=new Worker;
```

다른 한 건은,
``` c++
t= new thread(&Worker::run,w);
```

또한 main.cpp 에서 할당에 대한 누수를 볼 수 있다.
``` c++
rq=new Request();
```

이들 할당 자체에는 특별한 문제가 없을지라도 애플리케이션 생명 주기 동안에 이들을 추적하면 이들 객체에 대해 delete를 호출하지 않았음을 알 수 있을 것이다. 이들 메모리 누수를 수정하려면 Request 인스턴스에 대한 작업을 마친 후 이들을 삭제하여 dispatcher 클래스의 소멸자에서 Worker와 thread 인스턴스를 정리해야 한다.

이 데모 애플리케이션에서는 애플리케이션 종료 시점에 OS에 의해 전체 애플리케이션이 끝나고 정리되므로 이것은 실제로 문제가 되지 않는다. ==작업자 스레드의 수가 동적으로 증가하는 상황에서 새로운 요청이 계속해서 생성돼 추가되는 방식으로 이런 디스패처가 사용되는 애플리케이션이라면 실제로 문제가 발생한다.== 이런 경우 앞서 살펴본 메모리 누수는 해결하도록 조치를 취해야 한다.



### 오류 유형


Memcheck는 광범위한 메모리 관련 문제를 탐지할 수 있다. 다음 절에서 이들 오류와 그 의미를 요약한다.

##### 불법적인 읽기/ 불법적인 쓰기 오류

이들 오류는 일반적으로 다음의 형식으로 보고된다.

[그림]


이 오류 메시지의 첫 번째 라인은 유효하지 않은 읽기 또는 쓰기 접근인지를 알려준다. 다음 몇몇 라인은 유효하지 않은 읽기 또는 쓰기가 수행된 세부적 위치와 이들 코드가 호출된 곳(아마도 소스 파일 내의 라인)을 알려주는 백 트레이스다.

마지막 라인은 이미 해제된 메모리 블록에 대한 읽기와 같이 불법적인 접근 유형에 대한 세부 정보다.

이 유형의 오류는 접근하지 말아야 할 메모리 영역에 쓰기 작업을 하거나 읽기 작업을 했다는 표시다. ==이것은 와일드 포인터(즉, 임의의 메모리 주소를 참조하는)를 접근했거나 또는 잘못된 메모리 주소가 계산되도록 한 코드의 문제이거나,== ==메모리 경계를 준수하지 않거나, 배열 경계를 벗어난 읽기로 인해 발생할 수도 있다.==


일반적으로 이 유형의 오류가 보고되면 이것은 데이터 손상과 크래시뿐만 아니라 취약점으로 악용될 수 있는 버그로 이어질 수 있는 중대한 문제임을 나타내므로 매우 심각하게 받아들여야 한다.

### 초기화되지 않은 값의 사용

간단히 이것은 변수에 값이 할당되지 않은 채로 변수의 값이 사용되는 문제이다. 이 경우, 변수의 내용은 막 할당이 이뤄진 시점에 RAM의 해당 부분에 있던 그 내용이 될 가능성이 크다. 결과적으로 이것은 이들 내용이 사요오디거나 접근될 때 예상할 수 없는 동작으로 이어질 수 있다.

Memcheck는 이런 오류를 만나면 다음과 같은 유사한 오류를 던진다.

[그림]


이 일련의 오류는 다음의 작은 코드에 의해 유발된 것이다.

``` c++
#include <cstring>
#include <cstdio>

int main(){
int x;
printf("x=%d\n",x);
return 0;
}
```


이 코드에서 보다시피 임의의 값으로 설정돼 있을 변수를 초기화하지 않았다. 운이 좋다면 0 또는 유해하지 않는(희망 사항) 어떤 값으로 설정돼 있을 수도 있다. 이 코드는 초기화되지 않는 변수가 라이브러리 코드에 입력되는 방식을 보여준다.

초기화되지 않은 변수의 사용이 유해할 지의 여부는 단언하기 어렵지만 변수의 유형과 영향을 받는 코드에 주로 좌우된다. ==하지만, 초기화되지 않은 변수로 발생할 수 있는 (임의적으로) 이상한 문제를 찾아서 디버깅하는 것보다는 안전한 기본값을 할당하는 것이 훨씬 쉽다.==

초기화되지 않은 변수의 출처에 대한 추가적인 정보를 위해 -track-origins=yes 플래그를 Memcheck에 전달할 수 있다. 이 플래그는 Memcheck에게 변수별로 좀 더 많은 정보를 유지하도록 알려준다. 이런 정보를 통해 이러한 유형의 문제를 훨씬 쉽게 추적할 수 있다.


##### 초기화되지 않았거나 주소 지정이 불가능한 시스템 호출 값


함수가 호출될 때 **인자로 초기화되지 않은 값**이나 심지어 **주소 지정이 불가능한 버퍼에 대한 포인터가 전달**될 수 있다. 어느 경우이든 Memcheck는 다음과 같은 로그를 남긴다.


[그림]


이 로그는 다음 코드로 인해 발생된 것이다.

``` c++
#include <cstdlib>
#include <unistd.h>

int main(){
char *arr=(char*)malloc(10);
int* arr2=(int*)malloc(sizeof(int));
write(1,arr,10);
exit(arr2[0]);
}
```

이전 절에서 자세히 설명했듯이 초기화되지 않은 값의 일반적인 사용처럼, ==초기화되지 않았거나 의심스런 인자를 전달하는 것은 최소의 경우라도 위험하며 최악의 경우 크래시나 데이터 손상과 같은 원인이 된다.==



###### 불법적인 해제

불법적인 해제(free)나 삭제는 일반적으로 이미 해제된 메모리 블록에 대해 free() 또는 delete()를 다시 호출하려는 시도다. 이는 반드시 유해한 것은 아니지만 잘못된 설계이며 반드시 수정돼야 한다.

==이것은 메모리 블록의 시작을 가리키지 않은 포인터를 사용해 해당 메모리 블록을 해제하려고 할 때에도 발생할 수 있다.== 이것은 malloc( ) 또는 new()의 호출로 얻은 원본 포인터 대신에 복사본을 사용해 **포인터 연산을 해야 하는 주된 이유** 중 하나다.


##### 일치하지 않은 해제

==메모리 블록의 할당과 해제는 항상 상호 일치하는 함수를 사용해 수행돼야 한다.== 이것은 C 유형의 함수를 사용해 할당을 하면 할당 API와 대응하는 해제 함수를 사용해 해제해야 한다는 것을 의미한다. 이것은 C++ 유형의 할당과 해제에도 동일하게 적용된다.

간략히 말해 이것은 다음과 같은 의미를 지닌다.

- malloc 또는 calloc, valloc, realloc, memalign을 사용해 할당한다면 free로 해제해야 한다.
- new를 사용해 할당한다면 delete로 해제해야 한다.
- `new[]`를 사용해 할당한다면 `delete[]`로 해제해야 한다.


이들을 혼용해서 사용하더라도 문제가 발생하지 않을 수 있지만 예측할 수 없는 동작이 일어날 수 있다. ==마지막 유형의 할당과 해제는 배열에 한정된 것이다.== `new[]`로 할당된 배열에 `delete[]`를 사용하지 않는다면 메모리 누수나 더 나쁜 상황이 초래될 수 있다.


##### 소스와 대상의 겹침

이 유형의 오류는 전달된 소스와 대상 메모리 블록의 포인터가 겹친다는 것을 나타낸다(예상 크기를 근거로 하여). 이 유형의 버그 결과는 일반적으로 데이터 손상과 시스템 크래시의 형태를 띤다.


##### 수상한 인자 값

메모리 할당 함수의 경우, Memcheck는 이들에게 전달된 인자가 실제로 유효한지를 검증한다. 음수값을 전달하거나 합당한 예상을 훨씬 벗어나는 할당 크기(예를 들어 페타바이트[^1] 크기의 메모리 할당 요청)가 이런 예일 것이다. 대부분의 경우 이런 값들은 코드 내에서 이뤄진 잘못된 연산의 결과다.


Memcheck는 Memcheck메뉴얼에서 발췌한 이 예제와 같이 이런 오류를 다음과 같이 보고한다.

[그림]

여기서는 터무니 없이 malloc -3을 전달하려고 했다. 이것은 명확히 터무니없는 동작이기 때문에 코드의 심각한 버그임이 분명하다.

##### 메모리 누수 탐지

Memcheck의 메모리 누수에 관련된 보고에서 유념해야 할 가장 중요한 사항은 보고된 누수 중 상당량은 실제로 누수가 아니라는 것이다. 이것은 Memcheck가 발견한 잠재적 문제를 다음과 같이 보고하는 방식 때문이다.

- 명확한 손실(Deifinitely lost)
- 간접 손실(Indirectly lost)
- 가능한 손실(Possibly lost)

이들 가능한 세 보고 유형 중에서 포인터나 참조가 더 이상 존재하지 않아 문제의 메모리 블록이 더 이상 접근 불가능하며 애플리케이션이 해당 메모리를 해제할 수 없는 유일한 경우는 **명확한 손실**(Definitely lost) 유형이다.


간접 손실(Indirectly lost)의 경우, 메모리 블록 자체에 대한 포인터를 손실하지는 않았지만, 대신 해당 블을 참조하는 구조체에 대한 포인터를 손실한 것이다. 예를 들어 이것은 데이터 구조체(레드/블랙이나 바이너리 트리와 같이)의 루트 노드에 대한 접근을 직접적으로 손실할 때 발생할 수 있다. 결과적으로 이런 구조체의 자식 노드 또한 접근할 수 없게 된다.


마지막으로, 가능한 손실(Possibly lost)은 Memcheck가 메모리 블록에 대한 참조가 여전히 존재하는지 완전히 확신하지 못하는 **catch-all** 유형이다. ==이것은 특정 유형의 할당처럼 내부 포인터가 존재하는 경우에 발생할 수 있다.==

'Memcheck에 대한 기본 사용'절에서 앞서 언급했듯이, 메모리 누수가 발견된 정확한 지점에 관한 세부적 정보를 얻기 위해 --leak-check=full을 지정한 채로 Memcheck를 항상 실행하기를 권장한다.


### Helgrind

Helgrind의 목적은 멀티스레드 애플리케이션 내의 동기화 구현과 관련된 문제를 탐지하는 것이다. ==이것은 POSIX 스레드의 잘못된 사용과 잘못된 락 순서로 인한 잠재적 데드락, 스레드 동기화 없이 데이터를 읽고 쓰는 데이터 경쟁을 탐지할 수 있다.==

##### 기본 사용

다음과 같은 방식으로 예제의 애플리케이션에 대해 Helgrind를 시작한다.

```shell
$ valgrind --tool=helgrind --read-var-info=yes --logfile=dispatcher_helgrind.log ./dispatcher_demo
```

Memcheck를 실행하는 것과 유사하게 이것은 애플리케이션을 실행하고 생성된 모든 출력을 로그 파일에 기록하며 바이너리에 가용한 모든 디버깅 정보를 명시적으로 사용한다.

애플리케이션을 실행한 이후에 생성된 로그 파일을 살펴볼 수 있다.

[그림]

애플리케이션과 Valgrind 버전에 대한 기본적인 정보 다음에 루트 스레드가 생성됐다는 정보를 받는다.

[그림]

첫 번째 스레드가 디스패처에 의해 생성되고 로그로 남는다. 이제 다음과 같은 첫 번째 경고를 볼 것이다.

[그림]


방금 살펴본 경고에서 스레드 ID 1과 2 사이에서 크기가 1인 읽기의 충돌에 관해 Helgrind로부터 보고를 받는다. C++11 스레딩 API는 상당량의 템플릿을 사용하기 때문에 이 추적 내역은 읽기가 조금 어려울 수 있다. 핵심은 다음의 몇몇 라인에 존재한다.


[그림]

이것은 다음의 코드 라인에 해당한다.

``` c++
void setRequest(AbstractRequest* request){
this->request=request;
ready=true;
}

while(!ready&& running){}
```

이들 라인에서 크기 1인 유일한 변수는 불리언 변수 ready이다. 이것은 불리언 변수이므로 원자적 연산이 이루어진다는 것을 알 수 있다(자세한 사항은 8장,'원자적 동작-하드웨어와 작업하기'를 보자). 결과적으로 이 경고는 무시해도 된다.

이제 이 스레드에 대한 추가적인 경고를 받는다.

[그림]

첫 번재 경고와 유사하게 이것 또한 불리언 변수를 참조한다. 즉, Worker 인스턴스에서 running 변수를 참조한다. 이 또한 원자적 연산이므로 이 경고를 무시할 수 있다.

이 경고에 후속하여 다른 스레드에 대한 이들 경고가 반복된다. 또한 이 경고가 여러번 반복되는 것을 볼 수 있다.


[그림]

이 경고는 스레드 간에 표준 출력 사용이 동기화되지 않아서 유발된 것이다. 이 데모 애플리케이션의 로그 함수가 작업자 스레드에 의해 로그되는 텍스트를 동기화하기 위해 뮤텍스를 사용했지만 몇몇 곳에서는 안전하지 않는 방식으로 표준 출력에 기록한다.

이것은 중앙 집중적인 스레드 안전한 로그 함수를 사용해 상대적으로 쉽게 수정이 가능하다. 특별한 안정성 문제를 일으킬 것 같지는 않지만 로그 출력이 왜곡되어 사용할 수 없을 정도로 뒤섞여 버릴 가능성이 크다.



### pthreads API의 오사용

Helgrind는 pthreads API와 관련된 많은 오류를 탐지한다. 다음은 그 메뉴얼에 요약된 내용이다.

- 유효하지 않은 뮤텍스 언락
- 락되지 않은 뮤텍스의 언락
- 다른 스레드가 소유한 뮤텍스의 언락
- 유효하지 않거나 락된 뮤텍스의 언락
- 비재귀적인 뮤텍스를 재귀적으로 락하기
- 락된 뮤텍스를 포함한 메모리의 해제
- 리더-라이터(reader-writer) 락 인자를 기대하는 함수에 뮤텍스 인자를 전달하는 경우와 그 반대의 경우
- POSIX pthread 함수의 실패가 처리돼야 하는 오류 코드로 실패하는 경우
- 락된 락을 소유하는 동안 스레드가 종료되는 경우
- 락되지 않은 뮤텍스나 유효하지 않은 뮤텍스, 다른 스레드에 의해 락된 뮤텍스로 pthread_cond_wait를 호출하는 경우
- 조건 변수와 관련 뮤텍스 간의 불일치하는 결합(bindings)
- pthread 장벽의 유효하지 않거나 중복된 초기화
- 스레드가 여전히 대기 중인 pthread 장벽의 초기화
- 초기화되지 않거나 스레드가 여전히 대기 중인 pthread 장벽 객체의 해제 
- 초기화되지 않은 pthread 장벽에 대한 대기

이외에도 Helgrind 자체는 오류를 탐지하지 않지만 pthreads 라이브러리가 helgrind가 가로채는 각 함수에 대해 오류를 반환한다면, Helgrind에서도 오류가 발생한다.


### 락 순서 문제


락 순서 탐지는 일련의 락들이 특정 순서로 접근했다면 이들 락은 이 순서대로 항상 사용될 것이라는 가정을 사용한다. 예를 들어 두 락에 의해 보호되는 한 자원을 가정해보자. 4장, '스레드 동기화와 통신'의 디스패처 예제에서 살펴본 것처럼 Dispatcher 클래스에서 두 뮤텍스를 사용했다. 하나는 작업자 스레드에 대한 접근을, 다른 하나는 요청 인스턴스에 대한 접근을 각각 관리하기 위한 것이었다.

==이 코드의 올바른 구현에서 한 뮤텍스를 언락시킨 후에 다른 뮤텍스의 획득을 시도하도록 보장해야 한다.== 이것은 다른 스레드가 이미 두 번째 뮤텍스에 대한 접근을 획득한 상태에서 첫 번째 뮤텍스의 접근 획득을 시도해, 따라서 데드락 상황이 발생할 가능성이 존재하기 때문이다.

이 탐지 알고리즘은 유용하지만 현재로는 불완전한 부분이 존재함을 인식하는 것이 중요하다. 이것이 명확한 경우는 예를 들어 Helgrind에 의해 잘못된 것으로 보고되는 경향이 있는 락 순서를 그대로 사용하는 조건 변수를 이용할 때다.

여기서 유념할 것은 이들 로그 메시지를 조사해 그 장점을 판단해야 하지만, 멀티스레딩 API의 직접적인 잘못된 사용과는 달리 보고된 문제가 거짓-양성(false-positive)인지 아닌지는 덜 명확하다는 것이다.


### 데이터 경쟁

==기본적으로 데이터 경쟁은 둘 이상의 스레드가 동기화 메커니즘이 없이 동일한 자원에 대해 읽거나 쓰기를 시도할 때 발생한다.== 여기서는 동시에 읽고 쓰거나 또는 동시에 일어나는 두 개의 쓰기 작업이 실제로 문제가 된다. 따라서 이들 두 유형의 접근에 대해서만 보고가 된다.

기본 Helgrind 사용법에 관한 이전 절의 로그에서 이런 유형의 오류에 대한 몇몇 예를 봤다. 그 때는 변수에 대한 동시적 쓰기와 읽기에 관심을 기울였다. 그 절에서 다뤘듯이 Helgrind 자체는 쓰기나 읽기가 원자적인지에 대해서는 관심이 없고 단지 잠재적 문제만을 보고한다.

락 순서 문제와 유사하게 많은 보고가 거짓-양성을 띨 것이므로 이 문제 또한 사용자가 각 데이터 경쟁 보고에 대해 그 장점을 판단해야 한다.


### DRD

DRD는 애플리케이션에서 스레딩과 동기화 문제를 또한 탐지한다는 점에서 Helgrind와 매우 유사하다. DRD가 Helgrind와 주요하게 다른 점은 다음과 같다.

- DRD는 메모리를 더 작게 사용한다.
- DRD는 락 순서 위반을 탐지하지 않는다.
- DRD는 분리된(detached) 스레드를 지원한다.


일반적으로 DRD와 Helgrind를 모두 실행해 각각의 출력을 비교하기를 원할 수 있다. 많은 잠재적인 문제는 매우 비결정적이기 때문에 이들 두 툴을 함께 사용하면 가장 심각한 문제를 찾는 데 일반적으로 도움이 된다.


### 기본 사용


DRD를 시작하는 것은 다른 툴을 시작하는 것과 매우 유사하다. 다음과 같이 원하는 틀을 지정해주면 된다.


``` shell
$ valgrind --tool=drd --log-file=dispatcher_drd.log --read-var-info=yes ./dispatcher_demo
```


애플리케이션이 종료한 이후에 생성된 로그 파일의 내용을 살펴볼 수 있다.


[그림]

이 요약은 Helgrind 로그에서 본 것을 반복한다. 원자적 동작으로 인해 안심하고 무시할 수 있는 동일한 데이터 경쟁 보고(충돌하는 저장소)가 보인다. 이 특정 코드의 경우에는 DRD를 사용해도 Helgrind의 사용으로부터 알지 못했던 것을 더 추가하지는 않는다.



### 기능

DRD는 다음과 같은 오류를 탐지한다.

- 데이터 경쟁
- 락 경쟁(데드락과 지연)
- pthreads API의 오사용


세 번째 항목의 경우, 그 메뉴얼에 따라 따라 DRD에 의해 탐지되는 다음과 같은 오류 목록은 Helgrind의 목록과 매우 유사하다.

- 동기화 객체(예를 들어 뮤텍스)에 대한 한 유형의 주소를 다른 동기화 객체(예를 들어 조건 변수)의 유형에 대한 포인터를 기대하는 POSIX API 호출에 전달하는 경우
- 락 되지 않은 뮤텍스를 언락하려는 시도
- 다른 스레드에 의해 락된 뮤텍스를 언락하려는 시도
- PTHREAD_MUTEX_NORMAL 또는 스핀락 유형의 뮤텍스를 재귀적으로 락하려는 시도
- 락된 뮤텍스에 대한 소멸 또는 해제
- 해당 조건 변수와 관련된 뮤텍스에 대해 락이 안된 상태에서 이 조건 변수로 시그널을 보내는 경우
- 락이 안 됐거나(즉, 다른 스레드에 의해 락됐거나) 또는 재귀적으로 락이 된 뮤텍스에 대해 pthread_cond_wait를 호출하는 경우
- pthread_cond_wait를 통해 조건 변수에 서로 다른 두 뮤텍스를 연계시키는 경우
- 대기 중인 조건 변수의 소멸 또는 해제
- 락된 리더-라이터(reader-writer) 동기화 객체의 소멸 또는 해제
- 호출 스레드에 의해 락이 되지 않는 리더-라이터 동기화 객체를 언락하려는 시도
- 리더-라이터 동기화 객체를 배타적 용도로 재귀적으로 락하려는 시도
- 사용자 정의 리더-라이터 동기화 객체의 주소를 POSIX 스레드 함수에 전달하려는 시도
- POSIX 리더-라이터 동기화 객체의 주소를 사용자 정의 리더-라이터 동기화 객체에 대한 주석 중의 하나로 전달하려는 시도
- 뮤텍스나 조건 변수, 리더-라이터 락, 세마포어, 장벽에 대한 재초기화
- 장벽 대기와 장벽 소멸 간의 동기화 누락
- 스레드에 의해 락된 스핀락이나 뮤텍스, 리더-라이터 동기화 객체를 언락하지 않고서 해당 스레드가 종료하는 경우
- 유효하지 않은 스레드 ID를 pthread_join 또는 pthread_cancel로 전달하는 경우

앞서 언급했듯이 DRD은 분리된 스레드도 지원한다는 점은 여기서도 유용하다. 락 순서 검사가 중요한지의 여부는 애플리케이션에 달려 있다.


---
# C++11 스레드 지원

DRD 매뉴얼에는 C++11 스레드 지원에 관한 절이 포함돼 있다.

c++11 클래스 std::thread를 사용하고자 한다면 이 클래스의 구현에서 사용되는 `std::shared_ptr<>` 객체에 주석을 추가하려면 다음의 항목을 수행해야 한다.


- C++ 헤더 파일을 포함하기 전에 공통 헤더의 시작 부분이나 각 소스 파일의 시작 부분에 다음 코드를 추가한다.

``` c++
#include <valgrind/drd.h>

#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(addr)
ANNOTATE_HAPPENS_BEFORE(addr)
#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(addr)
ANNOTATE_HAPPENS_AFTER(addr)
```

- GCC 소스 코드를 다운로드 하여 libstdc++v3/src/c++11/thread.cc 소스파일에서 execute_native_thread_routine()와 `std::thread::_M_start_thread()` 함수의 구현을 독자의 애플리케이션과 링크할 소스 파일로 복사한다. 이 소스 파일에도 `_GLIBCXX_SYNCHRONIZATION_HAPPENS_*()` 매크로가 적절하게 정의돼 있는지 확인하자.

C++11 스레드 API를 사용하는 애플리케이션에 DRD를 사용할 때 많은 거짓-양성을 보게 될 수도 있다. 이것은 바로 전의 수정 사항으로 해결될 수 있다.


GCC 5.4dhk Valgrind 3.11(더 이전 버전을 사용 역시 가능하다)을 사용할 때, 이 문제는 더 이상 존재하지 않은 것처럼 보인다. 하지만, C++11 스레드 API를 사용하는 동안에 DRD 출력물에서 다수의 거짓-양성을 갑자기 보게 될 수도 있음을 유념해야 한다.


[^1]: 1,024TB


